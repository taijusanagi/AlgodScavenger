//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Algorand.Unity.Indexer;
using Algorand.Unity.LowLevel;
using Unity.Collections;
using UnityEngine;

namespace Algorand.Unity.Indexer
{
    [AlgoApiObject, Serializable]
    public partial struct Block
        : IEquatable<Block>
    {
        [SerializeField, Tooltip(@"")]
        BlockRewards @rewards;
        
        [SerializeField, Tooltip(@"[gh] hash to which this block belongs.")]
        byte[] @genesisHash;
        
        [SerializeField, Tooltip(@"")]
        BlockUpgradeState @upgradeState;
        
        [SerializeField, Tooltip(@"[prev] Previous block hash.")]
        byte[] @previousBlockHash;
        
        [SerializeField, Tooltip(@"[seed] Sortition seed.")]
        byte[] @seed;
        
        [SerializeField, Tooltip(@"[rnd] Current round on which this block was appended to the chain.")]
        ulong @round;
        
        [SerializeField, Tooltip(@"[txn] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.")]
        byte[] @transactionsRoot;
        
        [SerializeField, Tooltip(@"Tracks the status of state proofs.")]
        StateProofTracking[] @stateProofTracking;
        
        [SerializeField, Tooltip(@"[gen] ID to which this block belongs.")]
        string @genesisId;
        
        [SerializeField, Tooltip(@"[txn256] TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a vector commitment instead of a merkle tree, and SHA256 hash function instead of the default SHA512_256. This commitment can be used on environments where only the SHA256 function exists.")]
        byte[] @transactionsRootSha256;
        
        [SerializeField, Tooltip(@"")]
        BlockUpgradeVote @upgradeVote;
        
        [SerializeField, Tooltip(@"")]
        ParticipationUpdates @participationUpdates;
        
        [SerializeField, Tooltip(@"[txns] list of transactions corresponding to a given round.")]
        Transaction[] @transactions;
        
        [SerializeField, Tooltip(@"[ts] Block creation timestamp in seconds since eposh")]
        ulong @timestamp;
        
        [SerializeField, Tooltip(@"[tc] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.

Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).")]
        Optional<ulong> @txnCounter;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("rewards")]
        public BlockRewards Rewards
        {
            get => this.@rewards;
            set => this.@rewards = value;
        }

        /// <summary>
        /// [gh] hash to which this block belongs.        
        /// </summary>
        [AlgoApiField("genesis-hash")]
        public byte[] GenesisHash
        {
            get => this.@genesisHash;
            set => this.@genesisHash = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("upgrade-state")]
        public BlockUpgradeState UpgradeState
        {
            get => this.@upgradeState;
            set => this.@upgradeState = value;
        }

        /// <summary>
        /// [prev] Previous block hash.        
        /// </summary>
        [AlgoApiField("previous-block-hash")]
        public byte[] PreviousBlockHash
        {
            get => this.@previousBlockHash;
            set => this.@previousBlockHash = value;
        }

        /// <summary>
        /// [seed] Sortition seed.        
        /// </summary>
        [AlgoApiField("seed")]
        public byte[] Seed
        {
            get => this.@seed;
            set => this.@seed = value;
        }

        /// <summary>
        /// [rnd] Current round on which this block was appended to the chain.        
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        /// [txn] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.        
        /// </summary>
        [AlgoApiField("transactions-root")]
        public byte[] TransactionsRoot
        {
            get => this.@transactionsRoot;
            set => this.@transactionsRoot = value;
        }

        /// <summary>
        /// Tracks the status of state proofs.        
        /// </summary>
        [AlgoApiField("state-proof-tracking")]
        public StateProofTracking[] StateProofTracking
        {
            get => this.@stateProofTracking;
            set => this.@stateProofTracking = value;
        }

        /// <summary>
        /// [gen] ID to which this block belongs.        
        /// </summary>
        [AlgoApiField("genesis-id")]
        public string GenesisId
        {
            get => this.@genesisId;
            set => this.@genesisId = value;
        }

        /// <summary>
        /// [txn256] TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a vector commitment instead of a merkle tree, and SHA256 hash function instead of the default SHA512_256. This commitment can be used on environments where only the SHA256 function exists.        
        /// </summary>
        [AlgoApiField("transactions-root-sha256")]
        public byte[] TransactionsRootSha256
        {
            get => this.@transactionsRootSha256;
            set => this.@transactionsRootSha256 = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("upgrade-vote")]
        public BlockUpgradeVote UpgradeVote
        {
            get => this.@upgradeVote;
            set => this.@upgradeVote = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("participation-updates")]
        public ParticipationUpdates ParticipationUpdates
        {
            get => this.@participationUpdates;
            set => this.@participationUpdates = value;
        }

        /// <summary>
        /// [txns] list of transactions corresponding to a given round.        
        /// </summary>
        [AlgoApiField("transactions")]
        public Transaction[] Transactions
        {
            get => this.@transactions;
            set => this.@transactions = value;
        }

        /// <summary>
        /// [ts] Block creation timestamp in seconds since eposh        
        /// </summary>
        [AlgoApiField("timestamp")]
        public ulong Timestamp
        {
            get => this.@timestamp;
            set => this.@timestamp = value;
        }

        /// <summary>
        /// [tc] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.
        /// 
        /// Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).        
        /// </summary>
        [AlgoApiField("txn-counter")]
        public Optional<ulong> TxnCounter
        {
            get => this.@txnCounter;
            set => this.@txnCounter = value;
        }

        public bool Equals(Block other)
        {
            return 
                Rewards.Equals(other.Rewards) &&
                ArrayComparer.Equals(GenesisHash, other.GenesisHash) &&
                UpgradeState.Equals(other.UpgradeState) &&
                ArrayComparer.Equals(PreviousBlockHash, other.PreviousBlockHash) &&
                ArrayComparer.Equals(Seed, other.Seed) &&
                Round.Equals(other.Round) &&
                ArrayComparer.Equals(TransactionsRoot, other.TransactionsRoot) &&
                ArrayComparer.Equals(StateProofTracking, other.StateProofTracking) &&
                StringComparer.Equals(GenesisId, other.GenesisId) &&
                ArrayComparer.Equals(TransactionsRootSha256, other.TransactionsRootSha256) &&
                UpgradeVote.Equals(other.UpgradeVote) &&
                ParticipationUpdates.Equals(other.ParticipationUpdates) &&
                ArrayComparer.Equals(Transactions, other.Transactions) &&
                Timestamp.Equals(other.Timestamp) &&
                TxnCounter.Equals(other.TxnCounter)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct HashFactory
        : IEquatable<HashFactory>
    {
        [SerializeField, Tooltip(@"[t]")]
        Optional<ulong> @hashType;
        
        /// <summary>
        /// [t]        
        /// </summary>
        [AlgoApiField("hash-type")]
        public Optional<ulong> HashType
        {
            get => this.@hashType;
            set => this.@hashType = value;
        }

        public bool Equals(HashFactory other)
        {
            return 
                HashType.Equals(other.HashType)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureMultisig
        : IEquatable<TransactionSignatureMultisig>
    {
        [SerializeField, Tooltip(@"[subsig] holds pairs of public key and signatures.")]
        TransactionSignatureMultisigSubsignature[] @subsignature;
        
        [SerializeField, Tooltip(@"[thr]")]
        Optional<ulong> @threshold;
        
        [SerializeField, Tooltip(@"[v]")]
        Optional<ulong> @version;
        
        /// <summary>
        /// [subsig] holds pairs of public key and signatures.        
        /// </summary>
        [AlgoApiField("subsignature")]
        public TransactionSignatureMultisigSubsignature[] Subsignature
        {
            get => this.@subsignature;
            set => this.@subsignature = value;
        }

        /// <summary>
        /// [thr]        
        /// </summary>
        [AlgoApiField("threshold")]
        public Optional<ulong> Threshold
        {
            get => this.@threshold;
            set => this.@threshold = value;
        }

        /// <summary>
        /// [v]        
        /// </summary>
        [AlgoApiField("version")]
        public Optional<ulong> Version
        {
            get => this.@version;
            set => this.@version = value;
        }

        public bool Equals(TransactionSignatureMultisig other)
        {
            return 
                ArrayComparer.Equals(Subsignature, other.Subsignature) &&
                Threshold.Equals(other.Threshold) &&
                Version.Equals(other.Version)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ParticipationUpdates
        : IEquatable<ParticipationUpdates>
    {
        [SerializeField, Tooltip(@"[partupdrmv] a list of online accounts that needs to be converted to offline since their participation key expired.")]
        string[] @expiredParticipationAccounts;
        
        /// <summary>
        /// [partupdrmv] a list of online accounts that needs to be converted to offline since their participation key expired.        
        /// </summary>
        [AlgoApiField("expired-participation-accounts")]
        public string[] ExpiredParticipationAccounts
        {
            get => this.@expiredParticipationAccounts;
            set => this.@expiredParticipationAccounts = value;
        }

        public bool Equals(ParticipationUpdates other)
        {
            return 
                ArrayComparer.Equals(ExpiredParticipationAccounts, other.ExpiredParticipationAccounts)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationParams
        : IEquatable<ApplicationParams>
    {
        [SerializeField, Tooltip(@"The address that created this application. This is the address where the parameters and global state for this application can be found.")]
        Address @creator;
        
        [SerializeField, Tooltip(@"[approv] approval program.")]
        CompiledTeal @approvalProgram;
        
        [SerializeField, Tooltip(@"[clearp] approval program.")]
        CompiledTeal @clearStateProgram;
        
        [SerializeField, Tooltip(@"[lsch] local schema")]
        ApplicationStateSchema @localStateSchema;
        
        [SerializeField, Tooltip(@"[gsch] global schema")]
        ApplicationStateSchema @globalStateSchema;
        
        [SerializeField, Tooltip(@"[gs] global schema")]
        TealKeyValueStore @globalState;
        
        [SerializeField, Tooltip(@"[epp] the amount of extra program pages available to this app.")]
        Optional<ulong> @extraProgramPages;
        
        /// <summary>
        /// The address that created this application. This is the address where the parameters and global state for this application can be found.        
        /// </summary>
        [AlgoApiField("creator")]
        public Address Creator
        {
            get => this.@creator;
            set => this.@creator = value;
        }

        /// <summary>
        /// [approv] approval program.        
        /// </summary>
        [AlgoApiField("approval-program")]
        public CompiledTeal ApprovalProgram
        {
            get => this.@approvalProgram;
            set => this.@approvalProgram = value;
        }

        /// <summary>
        /// [clearp] approval program.        
        /// </summary>
        [AlgoApiField("clear-state-program")]
        public CompiledTeal ClearStateProgram
        {
            get => this.@clearStateProgram;
            set => this.@clearStateProgram = value;
        }

        /// <summary>
        /// [lsch] local schema        
        /// </summary>
        [AlgoApiField("local-state-schema")]
        public ApplicationStateSchema LocalStateSchema
        {
            get => this.@localStateSchema;
            set => this.@localStateSchema = value;
        }

        /// <summary>
        /// [gsch] global schema        
        /// </summary>
        [AlgoApiField("global-state-schema")]
        public ApplicationStateSchema GlobalStateSchema
        {
            get => this.@globalStateSchema;
            set => this.@globalStateSchema = value;
        }

        /// <summary>
        /// [gs] global schema        
        /// </summary>
        [AlgoApiField("global-state")]
        public TealKeyValueStore GlobalState
        {
            get => this.@globalState;
            set => this.@globalState = value;
        }

        /// <summary>
        /// [epp] the amount of extra program pages available to this app.        
        /// </summary>
        [AlgoApiField("extra-program-pages")]
        public Optional<ulong> ExtraProgramPages
        {
            get => this.@extraProgramPages;
            set => this.@extraProgramPages = value;
        }

        public bool Equals(ApplicationParams other)
        {
            return 
                Creator.Equals(other.Creator) &&
                ApprovalProgram.Equals(other.ApprovalProgram) &&
                ClearStateProgram.Equals(other.ClearStateProgram) &&
                LocalStateSchema.Equals(other.LocalStateSchema) &&
                GlobalStateSchema.Equals(other.GlobalStateSchema) &&
                GlobalState.Equals(other.GlobalState) &&
                ExtraProgramPages.Equals(other.ExtraProgramPages)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofTracking
        : IEquatable<StateProofTracking>
    {
        [SerializeField, Tooltip(@"State Proof Type. Note the raw object uses map with this as key.")]
        Optional<ulong> @type;
        
        [SerializeField, Tooltip(@"[v] Root of a vector commitment containing online accounts that will help sign the proof.")]
        byte[] @votersCommitment;
        
        [SerializeField, Tooltip(@"[t] The total number of microalgos held by the online accounts during the StateProof round.")]
        Optional<ulong> @onlineTotalWeight;
        
        [SerializeField, Tooltip(@"[n] Next round for which we will accept a state proof transaction.")]
        Optional<ulong> @nextRound;
        
        /// <summary>
        /// State Proof Type. Note the raw object uses map with this as key.        
        /// </summary>
        [AlgoApiField("type")]
        public Optional<ulong> Type
        {
            get => this.@type;
            set => this.@type = value;
        }

        /// <summary>
        /// [v] Root of a vector commitment containing online accounts that will help sign the proof.        
        /// </summary>
        [AlgoApiField("voters-commitment")]
        public byte[] VotersCommitment
        {
            get => this.@votersCommitment;
            set => this.@votersCommitment = value;
        }

        /// <summary>
        /// [t] The total number of microalgos held by the online accounts during the StateProof round.        
        /// </summary>
        [AlgoApiField("online-total-weight")]
        public Optional<ulong> OnlineTotalWeight
        {
            get => this.@onlineTotalWeight;
            set => this.@onlineTotalWeight = value;
        }

        /// <summary>
        /// [n] Next round for which we will accept a state proof transaction.        
        /// </summary>
        [AlgoApiField("next-round")]
        public Optional<ulong> NextRound
        {
            get => this.@nextRound;
            set => this.@nextRound = value;
        }

        public bool Equals(StateProofTracking other)
        {
            return 
                Type.Equals(other.Type) &&
                ArrayComparer.Equals(VotersCommitment, other.VotersCommitment) &&
                OnlineTotalWeight.Equals(other.OnlineTotalWeight) &&
                NextRound.Equals(other.NextRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TealValue
        : IEquatable<TealValue>
    {
        [SerializeField, Tooltip(@"[tt] value type. Value `1` refers to **bytes**, value `2` refers to **uint**")]
        ulong @type;
        
        [SerializeField, Tooltip(@"[tb] bytes value.")]
        string @bytes;
        
        [SerializeField, Tooltip(@"[ui] uint value.")]
        ulong @uint;
        
        /// <summary>
        /// [tt] value type. Value `1` refers to **bytes**, value `2` refers to **uint**        
        /// </summary>
        [AlgoApiField("type")]
        public ulong Type
        {
            get => this.@type;
            set => this.@type = value;
        }

        /// <summary>
        /// [tb] bytes value.        
        /// </summary>
        [AlgoApiField("bytes")]
        public string Bytes
        {
            get => this.@bytes;
            set => this.@bytes = value;
        }

        /// <summary>
        /// [ui] uint value.        
        /// </summary>
        [AlgoApiField("uint")]
        public ulong Uint
        {
            get => this.@uint;
            set => this.@uint = value;
        }

        public bool Equals(TealValue other)
        {
            return 
                Type.Equals(other.Type) &&
                StringComparer.Equals(Bytes, other.Bytes) &&
                Uint.Equals(other.Uint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureLogicsig
        : IEquatable<TransactionSignatureLogicsig>
    {
        [SerializeField, Tooltip(@"[arg] Logic arguments, base64 encoded.")]
        string[] @args;
        
        [SerializeField, Tooltip(@"[l] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.")]
        byte[] @logic;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignatureMultisig @multisigSignature;
        
        [SerializeField, Tooltip(@"[sig] ed25519 signature.")]
        byte[] @signature;
        
        /// <summary>
        /// [arg] Logic arguments, base64 encoded.        
        /// </summary>
        [AlgoApiField("args")]
        public string[] Args
        {
            get => this.@args;
            set => this.@args = value;
        }

        /// <summary>
        /// [l] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.        
        /// </summary>
        [AlgoApiField("logic")]
        public byte[] Logic
        {
            get => this.@logic;
            set => this.@logic = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("multisig-signature")]
        public TransactionSignatureMultisig MultisigSignature
        {
            get => this.@multisigSignature;
            set => this.@multisigSignature = value;
        }

        /// <summary>
        /// [sig] ed25519 signature.        
        /// </summary>
        [AlgoApiField("signature")]
        public byte[] Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        public bool Equals(TransactionSignatureLogicsig other)
        {
            return 
                ArrayComparer.Equals(Args, other.Args) &&
                ArrayComparer.Equals(Logic, other.Logic) &&
                MultisigSignature.Equals(other.MultisigSignature) &&
                ArrayComparer.Equals(Signature, other.Signature)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct EvalDelta
        : IEquatable<EvalDelta>
    {
        [SerializeField, Tooltip(@"[at] delta action.")]
        ulong @action;
        
        [SerializeField, Tooltip(@"[bs] bytes value.")]
        string @bytes;
        
        [SerializeField, Tooltip(@"[ui] uint value.")]
        Optional<ulong> @uint;
        
        /// <summary>
        /// [at] delta action.        
        /// </summary>
        [AlgoApiField("action")]
        public ulong Action
        {
            get => this.@action;
            set => this.@action = value;
        }

        /// <summary>
        /// [bs] bytes value.        
        /// </summary>
        [AlgoApiField("bytes")]
        public string Bytes
        {
            get => this.@bytes;
            set => this.@bytes = value;
        }

        /// <summary>
        /// [ui] uint value.        
        /// </summary>
        [AlgoApiField("uint")]
        public Optional<ulong> Uint
        {
            get => this.@uint;
            set => this.@uint = value;
        }

        public bool Equals(EvalDelta other)
        {
            return 
                Action.Equals(other.Action) &&
                StringComparer.Equals(Bytes, other.Bytes) &&
                Uint.Equals(other.Uint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionApplication
        : IEquatable<TransactionApplication>
    {
        [SerializeField, Tooltip(@"[apid] ID of the application being configured or empty if creating.")]
        ulong @applicationId;
        
        [SerializeField, Tooltip(@"[apap] Logic executed for every application transaction, except when on-completion is set to 'clear'. It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.")]
        CompiledTeal @approvalProgram;
        
        [SerializeField, Tooltip(@"[apfa] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.")]
        ulong[] @foreignApps;
        
        [SerializeField, Tooltip(@"[apaa] transaction specific arguments accessed from the application's approval-program and clear-state-program.")]
        string[] @applicationArgs;
        
        [SerializeField, Tooltip(@"")]
        OnCompletion @onCompletion;
        
        [SerializeField, Tooltip(@"")]
        StateSchema @globalStateSchema;
        
        [SerializeField, Tooltip(@"[epp] specifies the additional app program len requested in pages.")]
        Optional<ulong> @extraProgramPages;
        
        [SerializeField, Tooltip(@"[apas] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.")]
        ulong[] @foreignAssets;
        
        [SerializeField, Tooltip(@"")]
        StateSchema @localStateSchema;
        
        [SerializeField, Tooltip(@"[apat] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.")]
        Address[] @accounts;
        
        [SerializeField, Tooltip(@"[apsu] Logic executed for application transactions with on-completion set to 'clear'. It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.")]
        CompiledTeal @clearStateProgram;
        
        /// <summary>
        /// [apid] ID of the application being configured or empty if creating.        
        /// </summary>
        [AlgoApiField("application-id")]
        public ulong ApplicationId
        {
            get => this.@applicationId;
            set => this.@applicationId = value;
        }

        /// <summary>
        /// [apap] Logic executed for every application transaction, except when on-completion is set to 'clear'. It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.        
        /// </summary>
        [AlgoApiField("approval-program")]
        public CompiledTeal ApprovalProgram
        {
            get => this.@approvalProgram;
            set => this.@approvalProgram = value;
        }

        /// <summary>
        /// [apfa] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.        
        /// </summary>
        [AlgoApiField("foreign-apps")]
        public ulong[] ForeignApps
        {
            get => this.@foreignApps;
            set => this.@foreignApps = value;
        }

        /// <summary>
        /// [apaa] transaction specific arguments accessed from the application's approval-program and clear-state-program.        
        /// </summary>
        [AlgoApiField("application-args")]
        public string[] ApplicationArgs
        {
            get => this.@applicationArgs;
            set => this.@applicationArgs = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("on-completion")]
        public OnCompletion OnCompletion
        {
            get => this.@onCompletion;
            set => this.@onCompletion = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("global-state-schema")]
        public StateSchema GlobalStateSchema
        {
            get => this.@globalStateSchema;
            set => this.@globalStateSchema = value;
        }

        /// <summary>
        /// [epp] specifies the additional app program len requested in pages.        
        /// </summary>
        [AlgoApiField("extra-program-pages")]
        public Optional<ulong> ExtraProgramPages
        {
            get => this.@extraProgramPages;
            set => this.@extraProgramPages = value;
        }

        /// <summary>
        /// [apas] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.        
        /// </summary>
        [AlgoApiField("foreign-assets")]
        public ulong[] ForeignAssets
        {
            get => this.@foreignAssets;
            set => this.@foreignAssets = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("local-state-schema")]
        public StateSchema LocalStateSchema
        {
            get => this.@localStateSchema;
            set => this.@localStateSchema = value;
        }

        /// <summary>
        /// [apat] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.        
        /// </summary>
        [AlgoApiField("accounts")]
        public Address[] Accounts
        {
            get => this.@accounts;
            set => this.@accounts = value;
        }

        /// <summary>
        /// [apsu] Logic executed for application transactions with on-completion set to 'clear'. It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.        
        /// </summary>
        [AlgoApiField("clear-state-program")]
        public CompiledTeal ClearStateProgram
        {
            get => this.@clearStateProgram;
            set => this.@clearStateProgram = value;
        }

        public bool Equals(TransactionApplication other)
        {
            return 
                ApplicationId.Equals(other.ApplicationId) &&
                ApprovalProgram.Equals(other.ApprovalProgram) &&
                ArrayComparer.Equals(ForeignApps, other.ForeignApps) &&
                ArrayComparer.Equals(ApplicationArgs, other.ApplicationArgs) &&
                OnCompletion.Equals(other.OnCompletion) &&
                GlobalStateSchema.Equals(other.GlobalStateSchema) &&
                ExtraProgramPages.Equals(other.ExtraProgramPages) &&
                ArrayComparer.Equals(ForeignAssets, other.ForeignAssets) &&
                LocalStateSchema.Equals(other.LocalStateSchema) &&
                ArrayComparer.Equals(Accounts, other.Accounts) &&
                ClearStateProgram.Equals(other.ClearStateProgram)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationStateSchema
        : IEquatable<ApplicationStateSchema>
    {
        [SerializeField, Tooltip(@"[nui] num of uints.")]
        ulong @numUint;
        
        [SerializeField, Tooltip(@"[nbs] num of byte slices.")]
        ulong @numByteSlice;
        
        /// <summary>
        /// [nui] num of uints.        
        /// </summary>
        [AlgoApiField("num-uint")]
        public ulong NumUint
        {
            get => this.@numUint;
            set => this.@numUint = value;
        }

        /// <summary>
        /// [nbs] num of byte slices.        
        /// </summary>
        [AlgoApiField("num-byte-slice")]
        public ulong NumByteSlice
        {
            get => this.@numByteSlice;
            set => this.@numByteSlice = value;
        }

        public bool Equals(ApplicationStateSchema other)
        {
            return 
                NumUint.Equals(other.NumUint) &&
                NumByteSlice.Equals(other.NumByteSlice)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetConfig
        : IEquatable<TransactionAssetConfig>
    {
        [SerializeField, Tooltip(@"[xaid] ID of the asset being configured or empty if creating.")]
        Optional<ulong> @assetId;
        
        [SerializeField, Tooltip(@"")]
        AssetParams @params;
        
        /// <summary>
        /// [xaid] ID of the asset being configured or empty if creating.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public Optional<ulong> AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("params")]
        public AssetParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(TransactionAssetConfig other)
        {
            return 
                AssetId.Equals(other.AssetId) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionPayment
        : IEquatable<TransactionPayment>
    {
        [SerializeField, Tooltip(@"[amt] number of MicroAlgos intended to be transferred.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.")]
        Optional<ulong> @closeAmount;
        
        [SerializeField, Tooltip(@"[close] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.")]
        string @closeRemainderTo;
        
        [SerializeField, Tooltip(@"[rcv] receiver's address.")]
        string @receiver;
        
        /// <summary>
        /// [amt] number of MicroAlgos intended to be transferred.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.        
        /// </summary>
        [AlgoApiField("close-amount")]
        public Optional<ulong> CloseAmount
        {
            get => this.@closeAmount;
            set => this.@closeAmount = value;
        }

        /// <summary>
        /// [close] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.        
        /// </summary>
        [AlgoApiField("close-remainder-to")]
        public string CloseRemainderTo
        {
            get => this.@closeRemainderTo;
            set => this.@closeRemainderTo = value;
        }

        /// <summary>
        /// [rcv] receiver's address.        
        /// </summary>
        [AlgoApiField("receiver")]
        public string Receiver
        {
            get => this.@receiver;
            set => this.@receiver = value;
        }

        public bool Equals(TransactionPayment other)
        {
            return 
                Amount.Equals(other.Amount) &&
                CloseAmount.Equals(other.CloseAmount) &&
                StringComparer.Equals(CloseRemainderTo, other.CloseRemainderTo) &&
                StringComparer.Equals(Receiver, other.Receiver)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofFields
        : IEquatable<StateProofFields>
    {
        [SerializeField, Tooltip(@"[c]")]
        byte[] @sigCommit;
        
        [SerializeField, Tooltip(@"[w]")]
        Optional<ulong> @signedWeight;
        
        [SerializeField, Tooltip(@"[S]")]
        MerkleArrayProof @sigProofs;
        
        [SerializeField, Tooltip(@"[P]")]
        MerkleArrayProof @partProofs;
        
        [SerializeField, Tooltip(@"[v] Salt version of the merkle signature.")]
        Optional<ulong> @saltVersion;
        
        [SerializeField, Tooltip(@"[r] Note that this is actually stored as a map[uint64] - Reveal in the actual msgp")]
        StateProofReveal[] @reveals;
        
        [SerializeField, Tooltip(@"[pr] Sequence of reveal positions.")]
        ulong[] @positionsToReveal;
        
        /// <summary>
        /// [c]        
        /// </summary>
        [AlgoApiField("sig-commit")]
        public byte[] SigCommit
        {
            get => this.@sigCommit;
            set => this.@sigCommit = value;
        }

        /// <summary>
        /// [w]        
        /// </summary>
        [AlgoApiField("signed-weight")]
        public Optional<ulong> SignedWeight
        {
            get => this.@signedWeight;
            set => this.@signedWeight = value;
        }

        /// <summary>
        /// [S]        
        /// </summary>
        [AlgoApiField("sig-proofs")]
        public MerkleArrayProof SigProofs
        {
            get => this.@sigProofs;
            set => this.@sigProofs = value;
        }

        /// <summary>
        /// [P]        
        /// </summary>
        [AlgoApiField("part-proofs")]
        public MerkleArrayProof PartProofs
        {
            get => this.@partProofs;
            set => this.@partProofs = value;
        }

        /// <summary>
        /// [v] Salt version of the merkle signature.        
        /// </summary>
        [AlgoApiField("salt-version")]
        public Optional<ulong> SaltVersion
        {
            get => this.@saltVersion;
            set => this.@saltVersion = value;
        }

        /// <summary>
        /// [r] Note that this is actually stored as a map[uint64] - Reveal in the actual msgp        
        /// </summary>
        [AlgoApiField("reveals")]
        public StateProofReveal[] Reveals
        {
            get => this.@reveals;
            set => this.@reveals = value;
        }

        /// <summary>
        /// [pr] Sequence of reveal positions.        
        /// </summary>
        [AlgoApiField("positions-to-reveal")]
        public ulong[] PositionsToReveal
        {
            get => this.@positionsToReveal;
            set => this.@positionsToReveal = value;
        }

        public bool Equals(StateProofFields other)
        {
            return 
                ArrayComparer.Equals(SigCommit, other.SigCommit) &&
                SignedWeight.Equals(other.SignedWeight) &&
                SigProofs.Equals(other.SigProofs) &&
                PartProofs.Equals(other.PartProofs) &&
                SaltVersion.Equals(other.SaltVersion) &&
                ArrayComparer.Equals(Reveals, other.Reveals) &&
                ArrayComparer.Equals(PositionsToReveal, other.PositionsToReveal)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Box
        : IEquatable<Box>
    {
        [SerializeField, Tooltip(@"[name] box name, base64 encoded")]
        byte[] @name;
        
        [SerializeField, Tooltip(@"[value] box value, base64 encoded.")]
        byte[] @value;
        
        /// <summary>
        /// [name] box name, base64 encoded        
        /// </summary>
        [AlgoApiField("name")]
        public byte[] Name
        {
            get => this.@name;
            set => this.@name = value;
        }

        /// <summary>
        /// [value] box value, base64 encoded.        
        /// </summary>
        [AlgoApiField("value")]
        public byte[] Value
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(Box other)
        {
            return 
                ArrayComparer.Equals(Name, other.Name) &&
                ArrayComparer.Equals(Value, other.Value)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct MiniAssetHolding
        : IEquatable<MiniAssetHolding>
    {
        [SerializeField, Tooltip(@"")]
        string @address;
        
        [SerializeField, Tooltip(@"")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"")]
        bool @isFrozen;
        
        [SerializeField, Tooltip(@"Whether or not this asset holding is currently deleted from its account.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"Round during which the account opted into the asset.")]
        Optional<ulong> @optedInAtRound;
        
        [SerializeField, Tooltip(@"Round during which the account opted out of the asset.")]
        Optional<ulong> @optedOutAtRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("is-frozen")]
        public bool IsFrozen
        {
            get => this.@isFrozen;
            set => this.@isFrozen = value;
        }

        /// <summary>
        /// Whether or not this asset holding is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round during which the account opted into the asset.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public Optional<ulong> OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        /// Round during which the account opted out of the asset.        
        /// </summary>
        [AlgoApiField("opted-out-at-round")]
        public Optional<ulong> OptedOutAtRound
        {
            get => this.@optedOutAtRound;
            set => this.@optedOutAtRound = value;
        }

        public bool Equals(MiniAssetHolding other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                Amount.Equals(other.Amount) &&
                IsFrozen.Equals(other.IsFrozen) &&
                Deleted.Equals(other.Deleted) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                OptedOutAtRound.Equals(other.OptedOutAtRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofParticipant
        : IEquatable<StateProofParticipant>
    {
        [SerializeField, Tooltip(@"[p]")]
        StateProofVerifier @verifier;
        
        [SerializeField, Tooltip(@"[w]")]
        Optional<ulong> @weight;
        
        /// <summary>
        /// [p]        
        /// </summary>
        [AlgoApiField("verifier")]
        public StateProofVerifier Verifier
        {
            get => this.@verifier;
            set => this.@verifier = value;
        }

        /// <summary>
        /// [w]        
        /// </summary>
        [AlgoApiField("weight")]
        public Optional<ulong> Weight
        {
            get => this.@weight;
            set => this.@weight = value;
        }

        public bool Equals(StateProofParticipant other)
        {
            return 
                Verifier.Equals(other.Verifier) &&
                Weight.Equals(other.Weight)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLogData
        : IEquatable<ApplicationLogData>
    {
        [SerializeField, Tooltip(@"Transaction ID")]
        string @txid;
        
        [SerializeField, Tooltip(@"[lg] Logs for the application being executed by the transaction.")]
        byte[][] @logs;
        
        /// <summary>
        /// Transaction ID        
        /// </summary>
        [AlgoApiField("txid")]
        public string Txid
        {
            get => this.@txid;
            set => this.@txid = value;
        }

        /// <summary>
        /// [lg] Logs for the application being executed by the transaction.        
        /// </summary>
        [AlgoApiField("logs")]
        public byte[][] Logs
        {
            get => this.@logs;
            set => this.@logs = value;
        }

        public bool Equals(ApplicationLogData other)
        {
            return 
                StringComparer.Equals(Txid, other.Txid) &&
                ArrayComparer.Equals(Logs, other.Logs)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetFreeze
        : IEquatable<TransactionAssetFreeze>
    {
        [SerializeField, Tooltip(@"[fadd] Address of the account whose asset is being frozen or thawed.")]
        string @address;
        
        [SerializeField, Tooltip(@"[faid] ID of the asset being frozen or thawed.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"[afrz] The new freeze status.")]
        bool @newFreezeStatus;
        
        /// <summary>
        /// [fadd] Address of the account whose asset is being frozen or thawed.        
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        /// [faid] ID of the asset being frozen or thawed.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// [afrz] The new freeze status.        
        /// </summary>
        [AlgoApiField("new-freeze-status")]
        public bool NewFreezeStatus
        {
            get => this.@newFreezeStatus;
            set => this.@newFreezeStatus = value;
        }

        public bool Equals(TransactionAssetFreeze other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                AssetId.Equals(other.AssetId) &&
                NewFreezeStatus.Equals(other.NewFreezeStatus)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionKeyreg
        : IEquatable<TransactionKeyreg>
    {
        [SerializeField, Tooltip(@"[nonpart] Mark the account as participating or non-participating.")]
        Optional<bool> @nonParticipation;
        
        [SerializeField, Tooltip(@"[selkey] Public key used with the Verified Random Function (VRF) result during committee selection.")]
        byte[] @selectionParticipationKey;
        
        [SerializeField, Tooltip(@"[votefst] First round this participation key is valid.")]
        Optional<ulong> @voteFirstValid;
        
        [SerializeField, Tooltip(@"[votekd] Number of subkeys in each batch of participation keys.")]
        Optional<ulong> @voteKeyDilution;
        
        [SerializeField, Tooltip(@"[votelst] Last round this participation key is valid.")]
        Optional<ulong> @voteLastValid;
        
        [SerializeField, Tooltip(@"[votekey] Participation public key used in key registration transactions.")]
        byte[] @voteParticipationKey;
        
        [SerializeField, Tooltip(@"[sprfkey] State proof key used in key registration transactions.")]
        byte[] @stateProofKey;
        
        /// <summary>
        /// [nonpart] Mark the account as participating or non-participating.        
        /// </summary>
        [AlgoApiField("non-participation")]
        public Optional<bool> NonParticipation
        {
            get => this.@nonParticipation;
            set => this.@nonParticipation = value;
        }

        /// <summary>
        /// [selkey] Public key used with the Verified Random Function (VRF) result during committee selection.        
        /// </summary>
        [AlgoApiField("selection-participation-key")]
        public byte[] SelectionParticipationKey
        {
            get => this.@selectionParticipationKey;
            set => this.@selectionParticipationKey = value;
        }

        /// <summary>
        /// [votefst] First round this participation key is valid.        
        /// </summary>
        [AlgoApiField("vote-first-valid")]
        public Optional<ulong> VoteFirstValid
        {
            get => this.@voteFirstValid;
            set => this.@voteFirstValid = value;
        }

        /// <summary>
        /// [votekd] Number of subkeys in each batch of participation keys.        
        /// </summary>
        [AlgoApiField("vote-key-dilution")]
        public Optional<ulong> VoteKeyDilution
        {
            get => this.@voteKeyDilution;
            set => this.@voteKeyDilution = value;
        }

        /// <summary>
        /// [votelst] Last round this participation key is valid.        
        /// </summary>
        [AlgoApiField("vote-last-valid")]
        public Optional<ulong> VoteLastValid
        {
            get => this.@voteLastValid;
            set => this.@voteLastValid = value;
        }

        /// <summary>
        /// [votekey] Participation public key used in key registration transactions.        
        /// </summary>
        [AlgoApiField("vote-participation-key")]
        public byte[] VoteParticipationKey
        {
            get => this.@voteParticipationKey;
            set => this.@voteParticipationKey = value;
        }

        /// <summary>
        /// [sprfkey] State proof key used in key registration transactions.        
        /// </summary>
        [AlgoApiField("state-proof-key")]
        public byte[] StateProofKey
        {
            get => this.@stateProofKey;
            set => this.@stateProofKey = value;
        }

        public bool Equals(TransactionKeyreg other)
        {
            return 
                NonParticipation.Equals(other.NonParticipation) &&
                ArrayComparer.Equals(SelectionParticipationKey, other.SelectionParticipationKey) &&
                VoteFirstValid.Equals(other.VoteFirstValid) &&
                VoteKeyDilution.Equals(other.VoteKeyDilution) &&
                VoteLastValid.Equals(other.VoteLastValid) &&
                ArrayComparer.Equals(VoteParticipationKey, other.VoteParticipationKey) &&
                ArrayComparer.Equals(StateProofKey, other.StateProofKey)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignature
        : IEquatable<TransactionSignature>
    {
        [SerializeField, Tooltip(@"")]
        TransactionSignatureLogicsig @logicsig;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignatureMultisig @multisig;
        
        [SerializeField, Tooltip(@"[sig] Standard ed25519 signature.")]
        byte[] @sig;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("logicsig")]
        public TransactionSignatureLogicsig Logicsig
        {
            get => this.@logicsig;
            set => this.@logicsig = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("multisig")]
        public TransactionSignatureMultisig Multisig
        {
            get => this.@multisig;
            set => this.@multisig = value;
        }

        /// <summary>
        /// [sig] Standard ed25519 signature.        
        /// </summary>
        [AlgoApiField("sig")]
        public byte[] Sig
        {
            get => this.@sig;
            set => this.@sig = value;
        }

        public bool Equals(TransactionSignature other)
        {
            return 
                Logicsig.Equals(other.Logicsig) &&
                Multisig.Equals(other.Multisig) &&
                ArrayComparer.Equals(Sig, other.Sig)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Asset
        : IEquatable<Asset>
    {
        [SerializeField, Tooltip(@"unique asset identifier")]
        ulong @index;
        
        [SerializeField, Tooltip(@"Whether or not this asset is currently deleted.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"Round during which this asset was created.")]
        Optional<ulong> @createdAtRound;
        
        [SerializeField, Tooltip(@"Round during which this asset was destroyed.")]
        Optional<ulong> @destroyedAtRound;
        
        [SerializeField, Tooltip(@"")]
        AssetParams @params;
        
        /// <summary>
        /// unique asset identifier        
        /// </summary>
        [AlgoApiField("index")]
        public ulong Index
        {
            get => this.@index;
            set => this.@index = value;
        }

        /// <summary>
        /// Whether or not this asset is currently deleted.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round during which this asset was created.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public Optional<ulong> CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        /// Round during which this asset was destroyed.        
        /// </summary>
        [AlgoApiField("destroyed-at-round")]
        public Optional<ulong> DestroyedAtRound
        {
            get => this.@destroyedAtRound;
            set => this.@destroyedAtRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("params")]
        public AssetParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(Asset other)
        {
            return 
                Index.Equals(other.Index) &&
                Deleted.Equals(other.Deleted) &&
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                DestroyedAtRound.Equals(other.DestroyedAtRound) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofReveal
        : IEquatable<StateProofReveal>
    {
        [SerializeField, Tooltip(@"The position in the signature and participants arrays corresponding to this entry.")]
        Optional<ulong> @position;
        
        [SerializeField, Tooltip(@"[s]")]
        StateProofSigSlot @sigSlot;
        
        [SerializeField, Tooltip(@"[p]")]
        StateProofParticipant @participant;
        
        /// <summary>
        /// The position in the signature and participants arrays corresponding to this entry.        
        /// </summary>
        [AlgoApiField("position")]
        public Optional<ulong> Position
        {
            get => this.@position;
            set => this.@position = value;
        }

        /// <summary>
        /// [s]        
        /// </summary>
        [AlgoApiField("sig-slot")]
        public StateProofSigSlot SigSlot
        {
            get => this.@sigSlot;
            set => this.@sigSlot = value;
        }

        /// <summary>
        /// [p]        
        /// </summary>
        [AlgoApiField("participant")]
        public StateProofParticipant Participant
        {
            get => this.@participant;
            set => this.@participant = value;
        }

        public bool Equals(StateProofReveal other)
        {
            return 
                Position.Equals(other.Position) &&
                SigSlot.Equals(other.SigSlot) &&
                Participant.Equals(other.Participant)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TealKeyValue
        : IEquatable<TealKeyValue>
    {
        [SerializeField, Tooltip(@"")]
        string @key;
        
        [SerializeField, Tooltip(@"")]
        TealValue @value;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("key")]
        public string Key
        {
            get => this.@key;
            set => this.@key = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("value")]
        public TealValue Value
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(TealKeyValue other)
        {
            return 
                StringComparer.Equals(Key, other.Key) &&
                Value.Equals(other.Value)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct HealthCheck
        : IEquatable<HealthCheck>
    {
        [SerializeField, Tooltip(@"Current version.")]
        string @version;
        
        [SerializeField, Tooltip(@"")]
        AlgoApiObject @data;
        
        [SerializeField, Tooltip(@"")]
        ulong @round;
        
        [SerializeField, Tooltip(@"")]
        bool @isMigrating;
        
        [SerializeField, Tooltip(@"")]
        bool @dbAvailable;
        
        [SerializeField, Tooltip(@"")]
        string @message;
        
        [SerializeField, Tooltip(@"")]
        string[] @errors;
        
        /// <summary>
        /// Current version.        
        /// </summary>
        [AlgoApiField("version")]
        public string Version
        {
            get => this.@version;
            set => this.@version = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("data")]
        public AlgoApiObject Data
        {
            get => this.@data;
            set => this.@data = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("is-migrating")]
        public bool IsMigrating
        {
            get => this.@isMigrating;
            set => this.@isMigrating = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("db-available")]
        public bool DbAvailable
        {
            get => this.@dbAvailable;
            set => this.@dbAvailable = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("message")]
        public string Message
        {
            get => this.@message;
            set => this.@message = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("errors")]
        public string[] Errors
        {
            get => this.@errors;
            set => this.@errors = value;
        }

        public bool Equals(HealthCheck other)
        {
            return 
                StringComparer.Equals(Version, other.Version) &&
                Data.Equals(other.Data) &&
                Round.Equals(other.Round) &&
                IsMigrating.Equals(other.IsMigrating) &&
                DbAvailable.Equals(other.DbAvailable) &&
                StringComparer.Equals(Message, other.Message) &&
                ArrayComparer.Equals(Errors, other.Errors)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct EvalDeltaKeyValue
        : IEquatable<EvalDeltaKeyValue>
    {
        [SerializeField, Tooltip(@"")]
        string @key;
        
        [SerializeField, Tooltip(@"")]
        EvalDelta @value;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("key")]
        public string Key
        {
            get => this.@key;
            set => this.@key = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("value")]
        public EvalDelta Value
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(EvalDeltaKeyValue other)
        {
            return 
                StringComparer.Equals(Key, other.Key) &&
                Value.Equals(other.Value)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetHolding
        : IEquatable<AssetHolding>
    {
        [SerializeField, Tooltip(@"[a] number of units held.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Asset ID of the holding.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"[f] whether or not the holding is frozen.")]
        bool @isFrozen;
        
        [SerializeField, Tooltip(@"Whether or not the asset holding is currently deleted from its account.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"Round during which the account opted into this asset holding.")]
        Optional<ulong> @optedInAtRound;
        
        [SerializeField, Tooltip(@"Round during which the account opted out of this asset holding.")]
        Optional<ulong> @optedOutAtRound;
        
        /// <summary>
        /// [a] number of units held.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Asset ID of the holding.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// [f] whether or not the holding is frozen.        
        /// </summary>
        [AlgoApiField("is-frozen")]
        public bool IsFrozen
        {
            get => this.@isFrozen;
            set => this.@isFrozen = value;
        }

        /// <summary>
        /// Whether or not the asset holding is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round during which the account opted into this asset holding.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public Optional<ulong> OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        /// Round during which the account opted out of this asset holding.        
        /// </summary>
        [AlgoApiField("opted-out-at-round")]
        public Optional<ulong> OptedOutAtRound
        {
            get => this.@optedOutAtRound;
            set => this.@optedOutAtRound = value;
        }

        public bool Equals(AssetHolding other)
        {
            return 
                Amount.Equals(other.Amount) &&
                AssetId.Equals(other.AssetId) &&
                IsFrozen.Equals(other.IsFrozen) &&
                Deleted.Equals(other.Deleted) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                OptedOutAtRound.Equals(other.OptedOutAtRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Account
        : IEquatable<Account>
    {
        [SerializeField, Tooltip(@"[algo] total number of MicroAlgos in the account")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Whether or not this account is currently closed.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"the account public key")]
        string @address;
        
        [SerializeField, Tooltip(@"[ern] total rewards of MicroAlgos the account has received, including pending rewards.")]
        ulong @rewards;
        
        [SerializeField, Tooltip(@"Round during which this account was most recently closed.")]
        Optional<ulong> @closedAtRound;
        
        [SerializeField, Tooltip(@"specifies the amount of MicroAlgos in the account, without the pending rewards.")]
        ulong @amountWithoutPendingRewards;
        
        [SerializeField, Tooltip(@"[teap] the sum of all extra application program pages for this account.")]
        Optional<ulong> @appsTotalExtraPages;
        
        [SerializeField, Tooltip(@"The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.")]
        ulong @totalAssetsOptedIn;
        
        [SerializeField, Tooltip(@"[asset] assets held by this account.

Note the raw object uses `map[int] -> AssetHolding` for this type.")]
        AssetHolding[] @assets;
        
        [SerializeField, Tooltip(@"Round during which this account first appeared in a transaction.")]
        Optional<ulong> @createdAtRound;
        
        [SerializeField, Tooltip(@"")]
        AccountParticipation @participation;
        
        [SerializeField, Tooltip(@"For app-accounts only. The total number of bytes allocated for the keys and values of boxes which belong to the associated application.")]
        ulong @totalBoxBytes;
        
        [SerializeField, Tooltip(@"[tsch] stores the sum of all of the local schemas and global schemas in this account.

Note: the raw account uses `StateSchema` for this type.")]
        ApplicationStateSchema @appsTotalSchema;
        
        [SerializeField, Tooltip(@"The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.")]
        ulong @totalAppsOptedIn;
        
        [SerializeField, Tooltip(@"The round for which this information is relevant.")]
        ulong @round;
        
        [SerializeField, Tooltip(@"amount of MicroAlgos of pending rewards in this account.")]
        ulong @pendingRewards;
        
        [SerializeField, Tooltip(@"[appp] parameters of applications created by this account including app global data.

Note: the raw account uses `map[int] -> AppParams` for this type.")]
        Application[] @createdApps;
        
        [SerializeField, Tooltip(@"For app-accounts only. The total number of boxes which belong to the associated application.")]
        ulong @totalBoxes;
        
        [SerializeField, Tooltip(@"[onl] delegation status of the account's MicroAlgos
* Offline - indicates that the associated account is delegated.
*  Online  - indicates that the associated account used as part of the delegation pool.
*   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.")]
        string @status;
        
        [SerializeField, Tooltip(@"Indicates what type of signature is used by this account, must be one of:
* sig
* msig
* lsig
* or null if unknown")]
        SignatureType @sigType;
        
        [SerializeField, Tooltip(@"[spend] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.")]
        Address @authAddr;
        
        [SerializeField, Tooltip(@"The count of all assets (AssetParams objects) created by this account.")]
        ulong @totalCreatedAssets;
        
        [SerializeField, Tooltip(@"[ebase] used as part of the rewards computation. Only applicable to accounts which are participating.")]
        Optional<ulong> @rewardBase;
        
        [SerializeField, Tooltip(@"[apar] parameters of assets created by this account.

Note: the raw account uses `map[int] -> Asset` for this type.")]
        Asset[] @createdAssets;
        
        [SerializeField, Tooltip(@"[appl] applications local data stored in this account.

Note the raw object uses `map[int] -> AppLocalState` for this type.")]
        ApplicationLocalState[] @appsLocalState;
        
        [SerializeField, Tooltip(@"The count of all apps (AppParams objects) created by this account.")]
        ulong @totalCreatedApps;
        
        /// <summary>
        /// [algo] total number of MicroAlgos in the account        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Whether or not this account is currently closed.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// the account public key        
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        /// [ern] total rewards of MicroAlgos the account has received, including pending rewards.        
        /// </summary>
        [AlgoApiField("rewards")]
        public ulong Rewards
        {
            get => this.@rewards;
            set => this.@rewards = value;
        }

        /// <summary>
        /// Round during which this account was most recently closed.        
        /// </summary>
        [AlgoApiField("closed-at-round")]
        public Optional<ulong> ClosedAtRound
        {
            get => this.@closedAtRound;
            set => this.@closedAtRound = value;
        }

        /// <summary>
        /// specifies the amount of MicroAlgos in the account, without the pending rewards.        
        /// </summary>
        [AlgoApiField("amount-without-pending-rewards")]
        public ulong AmountWithoutPendingRewards
        {
            get => this.@amountWithoutPendingRewards;
            set => this.@amountWithoutPendingRewards = value;
        }

        /// <summary>
        /// [teap] the sum of all extra application program pages for this account.        
        /// </summary>
        [AlgoApiField("apps-total-extra-pages")]
        public Optional<ulong> AppsTotalExtraPages
        {
            get => this.@appsTotalExtraPages;
            set => this.@appsTotalExtraPages = value;
        }

        /// <summary>
        /// The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.        
        /// </summary>
        [AlgoApiField("total-assets-opted-in")]
        public ulong TotalAssetsOptedIn
        {
            get => this.@totalAssetsOptedIn;
            set => this.@totalAssetsOptedIn = value;
        }

        /// <summary>
        /// [asset] assets held by this account.
        /// 
        /// Note the raw object uses `map[int] -> AssetHolding` for this type.        
        /// </summary>
        [AlgoApiField("assets")]
        public AssetHolding[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        /// <summary>
        /// Round during which this account first appeared in a transaction.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public Optional<ulong> CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("participation")]
        public AccountParticipation Participation
        {
            get => this.@participation;
            set => this.@participation = value;
        }

        /// <summary>
        /// For app-accounts only. The total number of bytes allocated for the keys and values of boxes which belong to the associated application.        
        /// </summary>
        [AlgoApiField("total-box-bytes")]
        public ulong TotalBoxBytes
        {
            get => this.@totalBoxBytes;
            set => this.@totalBoxBytes = value;
        }

        /// <summary>
        /// [tsch] stores the sum of all of the local schemas and global schemas in this account.
        /// 
        /// Note: the raw account uses `StateSchema` for this type.        
        /// </summary>
        [AlgoApiField("apps-total-schema")]
        public ApplicationStateSchema AppsTotalSchema
        {
            get => this.@appsTotalSchema;
            set => this.@appsTotalSchema = value;
        }

        /// <summary>
        /// The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.        
        /// </summary>
        [AlgoApiField("total-apps-opted-in")]
        public ulong TotalAppsOptedIn
        {
            get => this.@totalAppsOptedIn;
            set => this.@totalAppsOptedIn = value;
        }

        /// <summary>
        /// The round for which this information is relevant.        
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        /// amount of MicroAlgos of pending rewards in this account.        
        /// </summary>
        [AlgoApiField("pending-rewards")]
        public ulong PendingRewards
        {
            get => this.@pendingRewards;
            set => this.@pendingRewards = value;
        }

        /// <summary>
        /// [appp] parameters of applications created by this account including app global data.
        /// 
        /// Note: the raw account uses `map[int] -> AppParams` for this type.        
        /// </summary>
        [AlgoApiField("created-apps")]
        public Application[] CreatedApps
        {
            get => this.@createdApps;
            set => this.@createdApps = value;
        }

        /// <summary>
        /// For app-accounts only. The total number of boxes which belong to the associated application.        
        /// </summary>
        [AlgoApiField("total-boxes")]
        public ulong TotalBoxes
        {
            get => this.@totalBoxes;
            set => this.@totalBoxes = value;
        }

        /// <summary>
        /// [onl] delegation status of the account's MicroAlgos
        /// * Offline - indicates that the associated account is delegated.
        /// *  Online  - indicates that the associated account used as part of the delegation pool.
        /// *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.        
        /// </summary>
        [AlgoApiField("status")]
        public string Status
        {
            get => this.@status;
            set => this.@status = value;
        }

        /// <summary>
        /// Indicates what type of signature is used by this account, must be one of:
        /// * sig
        /// * msig
        /// * lsig
        /// * or null if unknown        
        /// </summary>
        [AlgoApiField("sig-type")]
        public SignatureType SigType
        {
            get => this.@sigType;
            set => this.@sigType = value;
        }

        /// <summary>
        /// [spend] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.        
        /// </summary>
        [AlgoApiField("auth-addr")]
        public Address AuthAddr
        {
            get => this.@authAddr;
            set => this.@authAddr = value;
        }

        /// <summary>
        /// The count of all assets (AssetParams objects) created by this account.        
        /// </summary>
        [AlgoApiField("total-created-assets")]
        public ulong TotalCreatedAssets
        {
            get => this.@totalCreatedAssets;
            set => this.@totalCreatedAssets = value;
        }

        /// <summary>
        /// [ebase] used as part of the rewards computation. Only applicable to accounts which are participating.        
        /// </summary>
        [AlgoApiField("reward-base")]
        public Optional<ulong> RewardBase
        {
            get => this.@rewardBase;
            set => this.@rewardBase = value;
        }

        /// <summary>
        /// [apar] parameters of assets created by this account.
        /// 
        /// Note: the raw account uses `map[int] -> Asset` for this type.        
        /// </summary>
        [AlgoApiField("created-assets")]
        public Asset[] CreatedAssets
        {
            get => this.@createdAssets;
            set => this.@createdAssets = value;
        }

        /// <summary>
        /// [appl] applications local data stored in this account.
        /// 
        /// Note the raw object uses `map[int] -> AppLocalState` for this type.        
        /// </summary>
        [AlgoApiField("apps-local-state")]
        public ApplicationLocalState[] AppsLocalState
        {
            get => this.@appsLocalState;
            set => this.@appsLocalState = value;
        }

        /// <summary>
        /// The count of all apps (AppParams objects) created by this account.        
        /// </summary>
        [AlgoApiField("total-created-apps")]
        public ulong TotalCreatedApps
        {
            get => this.@totalCreatedApps;
            set => this.@totalCreatedApps = value;
        }

        public bool Equals(Account other)
        {
            return 
                Amount.Equals(other.Amount) &&
                Deleted.Equals(other.Deleted) &&
                StringComparer.Equals(Address, other.Address) &&
                Rewards.Equals(other.Rewards) &&
                ClosedAtRound.Equals(other.ClosedAtRound) &&
                AmountWithoutPendingRewards.Equals(other.AmountWithoutPendingRewards) &&
                AppsTotalExtraPages.Equals(other.AppsTotalExtraPages) &&
                TotalAssetsOptedIn.Equals(other.TotalAssetsOptedIn) &&
                ArrayComparer.Equals(Assets, other.Assets) &&
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                Participation.Equals(other.Participation) &&
                TotalBoxBytes.Equals(other.TotalBoxBytes) &&
                AppsTotalSchema.Equals(other.AppsTotalSchema) &&
                TotalAppsOptedIn.Equals(other.TotalAppsOptedIn) &&
                Round.Equals(other.Round) &&
                PendingRewards.Equals(other.PendingRewards) &&
                ArrayComparer.Equals(CreatedApps, other.CreatedApps) &&
                TotalBoxes.Equals(other.TotalBoxes) &&
                StringComparer.Equals(Status, other.Status) &&
                SigType.Equals(other.SigType) &&
                AuthAddr.Equals(other.AuthAddr) &&
                TotalCreatedAssets.Equals(other.TotalCreatedAssets) &&
                RewardBase.Equals(other.RewardBase) &&
                ArrayComparer.Equals(CreatedAssets, other.CreatedAssets) &&
                ArrayComparer.Equals(AppsLocalState, other.AppsLocalState) &&
                TotalCreatedApps.Equals(other.TotalCreatedApps)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockRewards
        : IEquatable<BlockRewards>
    {
        [SerializeField, Tooltip(@"[fees] accepts transaction fees, it can only spend to the incentive pool.")]
        string @feeSink;
        
        [SerializeField, Tooltip(@"[rwcalr] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.")]
        ulong @rewardsCalculationRound;
        
        [SerializeField, Tooltip(@"[earn] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.")]
        ulong @rewardsLevel;
        
        [SerializeField, Tooltip(@"[rwd] accepts periodic injections from the fee-sink and continually redistributes them as rewards.")]
        string @rewardsPool;
        
        [SerializeField, Tooltip(@"[rate] Number of new MicroAlgos added to the participation stake from rewards at the next round.")]
        ulong @rewardsRate;
        
        [SerializeField, Tooltip(@"[frac] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.")]
        ulong @rewardsResidue;
        
        /// <summary>
        /// [fees] accepts transaction fees, it can only spend to the incentive pool.        
        /// </summary>
        [AlgoApiField("fee-sink")]
        public string FeeSink
        {
            get => this.@feeSink;
            set => this.@feeSink = value;
        }

        /// <summary>
        /// [rwcalr] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.        
        /// </summary>
        [AlgoApiField("rewards-calculation-round")]
        public ulong RewardsCalculationRound
        {
            get => this.@rewardsCalculationRound;
            set => this.@rewardsCalculationRound = value;
        }

        /// <summary>
        /// [earn] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.        
        /// </summary>
        [AlgoApiField("rewards-level")]
        public ulong RewardsLevel
        {
            get => this.@rewardsLevel;
            set => this.@rewardsLevel = value;
        }

        /// <summary>
        /// [rwd] accepts periodic injections from the fee-sink and continually redistributes them as rewards.        
        /// </summary>
        [AlgoApiField("rewards-pool")]
        public string RewardsPool
        {
            get => this.@rewardsPool;
            set => this.@rewardsPool = value;
        }

        /// <summary>
        /// [rate] Number of new MicroAlgos added to the participation stake from rewards at the next round.        
        /// </summary>
        [AlgoApiField("rewards-rate")]
        public ulong RewardsRate
        {
            get => this.@rewardsRate;
            set => this.@rewardsRate = value;
        }

        /// <summary>
        /// [frac] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.        
        /// </summary>
        [AlgoApiField("rewards-residue")]
        public ulong RewardsResidue
        {
            get => this.@rewardsResidue;
            set => this.@rewardsResidue = value;
        }

        public bool Equals(BlockRewards other)
        {
            return 
                StringComparer.Equals(FeeSink, other.FeeSink) &&
                RewardsCalculationRound.Equals(other.RewardsCalculationRound) &&
                RewardsLevel.Equals(other.RewardsLevel) &&
                StringComparer.Equals(RewardsPool, other.RewardsPool) &&
                RewardsRate.Equals(other.RewardsRate) &&
                RewardsResidue.Equals(other.RewardsResidue)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofSignature
        : IEquatable<StateProofSignature>
    {
        [SerializeField, Tooltip(@"")]
        byte[] @falconSignature;
        
        [SerializeField, Tooltip(@"")]
        Optional<ulong> @merkleArrayIndex;
        
        [SerializeField, Tooltip(@"")]
        MerkleArrayProof @proof;
        
        [SerializeField, Tooltip(@"[vkey]")]
        byte[] @verifyingKey;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("falcon-signature")]
        public byte[] FalconSignature
        {
            get => this.@falconSignature;
            set => this.@falconSignature = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("merkle-array-index")]
        public Optional<ulong> MerkleArrayIndex
        {
            get => this.@merkleArrayIndex;
            set => this.@merkleArrayIndex = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("proof")]
        public MerkleArrayProof Proof
        {
            get => this.@proof;
            set => this.@proof = value;
        }

        /// <summary>
        /// [vkey]        
        /// </summary>
        [AlgoApiField("verifying-key")]
        public byte[] VerifyingKey
        {
            get => this.@verifyingKey;
            set => this.@verifyingKey = value;
        }

        public bool Equals(StateProofSignature other)
        {
            return 
                ArrayComparer.Equals(FalconSignature, other.FalconSignature) &&
                MerkleArrayIndex.Equals(other.MerkleArrayIndex) &&
                Proof.Equals(other.Proof) &&
                ArrayComparer.Equals(VerifyingKey, other.VerifyingKey)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountStateDelta
        : IEquatable<AccountStateDelta>
    {
        [SerializeField, Tooltip(@"")]
        string @address;
        
        [SerializeField, Tooltip(@"")]
        StateDelta @delta;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("delta")]
        public StateDelta Delta
        {
            get => this.@delta;
            set => this.@delta = value;
        }

        public bool Equals(AccountStateDelta other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                Delta.Equals(other.Delta)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockUpgradeVote
        : IEquatable<BlockUpgradeVote>
    {
        [SerializeField, Tooltip(@"[upgradeyes] Indicates a yes vote for the current proposal.")]
        Optional<bool> @upgradeApprove;
        
        [SerializeField, Tooltip(@"[upgradedelay] Indicates the time between acceptance and execution.")]
        Optional<ulong> @upgradeDelay;
        
        [SerializeField, Tooltip(@"[upgradeprop] Indicates a proposed upgrade.")]
        string @upgradePropose;
        
        /// <summary>
        /// [upgradeyes] Indicates a yes vote for the current proposal.        
        /// </summary>
        [AlgoApiField("upgrade-approve")]
        public Optional<bool> UpgradeApprove
        {
            get => this.@upgradeApprove;
            set => this.@upgradeApprove = value;
        }

        /// <summary>
        /// [upgradedelay] Indicates the time between acceptance and execution.        
        /// </summary>
        [AlgoApiField("upgrade-delay")]
        public Optional<ulong> UpgradeDelay
        {
            get => this.@upgradeDelay;
            set => this.@upgradeDelay = value;
        }

        /// <summary>
        /// [upgradeprop] Indicates a proposed upgrade.        
        /// </summary>
        [AlgoApiField("upgrade-propose")]
        public string UpgradePropose
        {
            get => this.@upgradePropose;
            set => this.@upgradePropose = value;
        }

        public bool Equals(BlockUpgradeVote other)
        {
            return 
                UpgradeApprove.Equals(other.UpgradeApprove) &&
                UpgradeDelay.Equals(other.UpgradeDelay) &&
                StringComparer.Equals(UpgradePropose, other.UpgradePropose)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Application
        : IEquatable<Application>
    {
        [SerializeField, Tooltip(@"[appidx] application index.")]
        ulong @id;
        
        [SerializeField, Tooltip(@"Whether or not this application is currently deleted.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"Round when this application was created.")]
        Optional<ulong> @createdAtRound;
        
        [SerializeField, Tooltip(@"Round when this application was deleted.")]
        Optional<ulong> @deletedAtRound;
        
        [SerializeField, Tooltip(@"[appparams] application parameters.")]
        ApplicationParams @params;
        
        /// <summary>
        /// [appidx] application index.        
        /// </summary>
        [AlgoApiField("id")]
        public ulong Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        /// Whether or not this application is currently deleted.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round when this application was created.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public Optional<ulong> CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        /// Round when this application was deleted.        
        /// </summary>
        [AlgoApiField("deleted-at-round")]
        public Optional<ulong> DeletedAtRound
        {
            get => this.@deletedAtRound;
            set => this.@deletedAtRound = value;
        }

        /// <summary>
        /// [appparams] application parameters.        
        /// </summary>
        [AlgoApiField("params")]
        public ApplicationParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(Application other)
        {
            return 
                Id.Equals(other.Id) &&
                Deleted.Equals(other.Deleted) &&
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                DeletedAtRound.Equals(other.DeletedAtRound) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateSchema
        : IEquatable<StateSchema>
    {
        [SerializeField, Tooltip(@"Maximum number of TEAL uints that may be stored in the key/value store.")]
        ulong @numUint;
        
        [SerializeField, Tooltip(@"Maximum number of TEAL byte slices that may be stored in the key/value store.")]
        ulong @numByteSlice;
        
        /// <summary>
        /// Maximum number of TEAL uints that may be stored in the key/value store.        
        /// </summary>
        [AlgoApiField("num-uint")]
        public ulong NumUint
        {
            get => this.@numUint;
            set => this.@numUint = value;
        }

        /// <summary>
        /// Maximum number of TEAL byte slices that may be stored in the key/value store.        
        /// </summary>
        [AlgoApiField("num-byte-slice")]
        public ulong NumByteSlice
        {
            get => this.@numByteSlice;
            set => this.@numByteSlice = value;
        }

        public bool Equals(StateSchema other)
        {
            return 
                NumUint.Equals(other.NumUint) &&
                NumByteSlice.Equals(other.NumByteSlice)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLocalState
        : IEquatable<ApplicationLocalState>
    {
        [SerializeField, Tooltip(@"The application which this local state is for.")]
        ulong @id;
        
        [SerializeField, Tooltip(@"Whether or not the application local state is currently deleted from its account.")]
        Optional<bool> @deleted;
        
        [SerializeField, Tooltip(@"Round when the account opted into the application.")]
        Optional<ulong> @optedInAtRound;
        
        [SerializeField, Tooltip(@"Round when account closed out of the application.")]
        Optional<ulong> @closedOutAtRound;
        
        [SerializeField, Tooltip(@"[hsch] schema.")]
        ApplicationStateSchema @schema;
        
        [SerializeField, Tooltip(@"[tkv] storage.")]
        TealKeyValueStore @keyValue;
        
        /// <summary>
        /// The application which this local state is for.        
        /// </summary>
        [AlgoApiField("id")]
        public ulong Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        /// Whether or not the application local state is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public Optional<bool> Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round when the account opted into the application.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public Optional<ulong> OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        /// Round when account closed out of the application.        
        /// </summary>
        [AlgoApiField("closed-out-at-round")]
        public Optional<ulong> ClosedOutAtRound
        {
            get => this.@closedOutAtRound;
            set => this.@closedOutAtRound = value;
        }

        /// <summary>
        /// [hsch] schema.        
        /// </summary>
        [AlgoApiField("schema")]
        public ApplicationStateSchema Schema
        {
            get => this.@schema;
            set => this.@schema = value;
        }

        /// <summary>
        /// [tkv] storage.        
        /// </summary>
        [AlgoApiField("key-value")]
        public TealKeyValueStore KeyValue
        {
            get => this.@keyValue;
            set => this.@keyValue = value;
        }

        public bool Equals(ApplicationLocalState other)
        {
            return 
                Id.Equals(other.Id) &&
                Deleted.Equals(other.Deleted) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                ClosedOutAtRound.Equals(other.ClosedOutAtRound) &&
                Schema.Equals(other.Schema) &&
                KeyValue.Equals(other.KeyValue)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BoxDescriptor
        : IEquatable<BoxDescriptor>
    {
        [SerializeField, Tooltip(@"Base64 encoded box name")]
        byte[] @name;
        
        /// <summary>
        /// Base64 encoded box name        
        /// </summary>
        [AlgoApiField("name")]
        public byte[] Name
        {
            get => this.@name;
            set => this.@name = value;
        }

        public bool Equals(BoxDescriptor other)
        {
            return 
                ArrayComparer.Equals(Name, other.Name)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureMultisigSubsignature
        : IEquatable<TransactionSignatureMultisigSubsignature>
    {
        [SerializeField, Tooltip(@"[pk]")]
        byte[] @publicKey;
        
        [SerializeField, Tooltip(@"[s]")]
        byte[] @signature;
        
        /// <summary>
        /// [pk]        
        /// </summary>
        [AlgoApiField("public-key")]
        public byte[] PublicKey
        {
            get => this.@publicKey;
            set => this.@publicKey = value;
        }

        /// <summary>
        /// [s]        
        /// </summary>
        [AlgoApiField("signature")]
        public byte[] Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        public bool Equals(TransactionSignatureMultisigSubsignature other)
        {
            return 
                ArrayComparer.Equals(PublicKey, other.PublicKey) &&
                ArrayComparer.Equals(Signature, other.Signature)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountParticipation
        : IEquatable<AccountParticipation>
    {
        [SerializeField, Tooltip(@"[sel] Selection public key (if any) currently registered for this round.")]
        byte[] @selectionParticipationKey;
        
        [SerializeField, Tooltip(@"[voteFst] First round for which this participation is valid.")]
        ulong @voteFirstValid;
        
        [SerializeField, Tooltip(@"[voteKD] Number of subkeys in each batch of participation keys.")]
        ulong @voteKeyDilution;
        
        [SerializeField, Tooltip(@"[voteLst] Last round for which this participation is valid.")]
        ulong @voteLastValid;
        
        [SerializeField, Tooltip(@"[vote] root participation public key (if any) currently registered for this round.")]
        byte[] @voteParticipationKey;
        
        [SerializeField, Tooltip(@"[stprf] Root of the state proof key (if any)")]
        byte[] @stateProofKey;
        
        /// <summary>
        /// [sel] Selection public key (if any) currently registered for this round.        
        /// </summary>
        [AlgoApiField("selection-participation-key")]
        public byte[] SelectionParticipationKey
        {
            get => this.@selectionParticipationKey;
            set => this.@selectionParticipationKey = value;
        }

        /// <summary>
        /// [voteFst] First round for which this participation is valid.        
        /// </summary>
        [AlgoApiField("vote-first-valid")]
        public ulong VoteFirstValid
        {
            get => this.@voteFirstValid;
            set => this.@voteFirstValid = value;
        }

        /// <summary>
        /// [voteKD] Number of subkeys in each batch of participation keys.        
        /// </summary>
        [AlgoApiField("vote-key-dilution")]
        public ulong VoteKeyDilution
        {
            get => this.@voteKeyDilution;
            set => this.@voteKeyDilution = value;
        }

        /// <summary>
        /// [voteLst] Last round for which this participation is valid.        
        /// </summary>
        [AlgoApiField("vote-last-valid")]
        public ulong VoteLastValid
        {
            get => this.@voteLastValid;
            set => this.@voteLastValid = value;
        }

        /// <summary>
        /// [vote] root participation public key (if any) currently registered for this round.        
        /// </summary>
        [AlgoApiField("vote-participation-key")]
        public byte[] VoteParticipationKey
        {
            get => this.@voteParticipationKey;
            set => this.@voteParticipationKey = value;
        }

        /// <summary>
        /// [stprf] Root of the state proof key (if any)        
        /// </summary>
        [AlgoApiField("state-proof-key")]
        public byte[] StateProofKey
        {
            get => this.@stateProofKey;
            set => this.@stateProofKey = value;
        }

        public bool Equals(AccountParticipation other)
        {
            return 
                ArrayComparer.Equals(SelectionParticipationKey, other.SelectionParticipationKey) &&
                VoteFirstValid.Equals(other.VoteFirstValid) &&
                VoteKeyDilution.Equals(other.VoteKeyDilution) &&
                VoteLastValid.Equals(other.VoteLastValid) &&
                ArrayComparer.Equals(VoteParticipationKey, other.VoteParticipationKey) &&
                ArrayComparer.Equals(StateProofKey, other.StateProofKey)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetTransfer
        : IEquatable<TransactionAssetTransfer>
    {
        [SerializeField, Tooltip(@"[aamt] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"[xaid] ID of the asset being transferred.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"Number of assets transfered to the close-to account as part of the transaction.")]
        Optional<ulong> @closeAmount;
        
        [SerializeField, Tooltip(@"[aclose] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.")]
        string @closeTo;
        
        [SerializeField, Tooltip(@"[arcv] Recipient address of the transfer.")]
        string @receiver;
        
        [SerializeField, Tooltip(@"[asnd] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.")]
        string @sender;
        
        /// <summary>
        /// [aamt] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// [xaid] ID of the asset being transferred.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// Number of assets transfered to the close-to account as part of the transaction.        
        /// </summary>
        [AlgoApiField("close-amount")]
        public Optional<ulong> CloseAmount
        {
            get => this.@closeAmount;
            set => this.@closeAmount = value;
        }

        /// <summary>
        /// [aclose] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.        
        /// </summary>
        [AlgoApiField("close-to")]
        public string CloseTo
        {
            get => this.@closeTo;
            set => this.@closeTo = value;
        }

        /// <summary>
        /// [arcv] Recipient address of the transfer.        
        /// </summary>
        [AlgoApiField("receiver")]
        public string Receiver
        {
            get => this.@receiver;
            set => this.@receiver = value;
        }

        /// <summary>
        /// [asnd] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.        
        /// </summary>
        [AlgoApiField("sender")]
        public string Sender
        {
            get => this.@sender;
            set => this.@sender = value;
        }

        public bool Equals(TransactionAssetTransfer other)
        {
            return 
                Amount.Equals(other.Amount) &&
                AssetId.Equals(other.AssetId) &&
                CloseAmount.Equals(other.CloseAmount) &&
                StringComparer.Equals(CloseTo, other.CloseTo) &&
                StringComparer.Equals(Receiver, other.Receiver) &&
                StringComparer.Equals(Sender, other.Sender)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Transaction
        : IEquatable<Transaction>
    {
        [SerializeField, Tooltip(@"")]
        TransactionStateProof @stateProofTransaction;
        
        [SerializeField, Tooltip(@"[fee] Transaction fee.")]
        ulong @fee;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetTransfer @assetTransferTransaction;
        
        [SerializeField, Tooltip(@"[grp] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.")]
        byte[] @group;
        
        [SerializeField, Tooltip(@"Specifies an application index (ID) if an application was created with this transaction.")]
        Optional<ulong> @createdApplicationIndex;
        
        [SerializeField, Tooltip(@"[lx] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.")]
        byte[] @lease;
        
        [SerializeField, Tooltip(@"[gh] Hash of genesis block.")]
        byte[] @genesisHash;
        
        [SerializeField, Tooltip(@"[lg] Logs for the application being executed by this transaction.")]
        byte[][] @logs;
        
        [SerializeField, Tooltip(@"[rs] rewards applied to sender account.")]
        Optional<ulong> @senderRewards;
        
        [SerializeField, Tooltip(@"[ca] closing amount for transaction.")]
        Optional<ulong> @closingAmount;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignature @signature;
        
        [SerializeField, Tooltip(@"[gd] Global state key/value changes for the application being executed by this transaction.")]
        StateDelta @globalStateDelta;
        
        [SerializeField, Tooltip(@"[type] Indicates what type of transaction this is. Different types have different fields.

Valid types, and where their fields are stored:
* [pay] payment-transaction
* [keyreg] keyreg-transaction
* [acfg] asset-config-transaction
* [axfer] asset-transfer-transaction
* [afrz] asset-freeze-transaction
* [appl] application-transaction
* [stpf] state-proof-transaction")]
        string @txType;
        
        [SerializeField, Tooltip(@"Offset into the round where this transaction was confirmed.")]
        Optional<ulong> @intraRoundOffset;
        
        [SerializeField, Tooltip(@"")]
        TransactionPayment @paymentTransaction;
        
        [SerializeField, Tooltip(@"")]
        TransactionKeyreg @keyregTransaction;
        
        [SerializeField, Tooltip(@"Round when the transaction was confirmed.")]
        Optional<ulong> @confirmedRound;
        
        [SerializeField, Tooltip(@"[note] Free form data.")]
        byte[] @note;
        
        [SerializeField, Tooltip(@"[rr] rewards applied to receiver account.")]
        Optional<ulong> @receiverRewards;
        
        [SerializeField, Tooltip(@"Time when the block this transaction is in was confirmed.")]
        Optional<ulong> @roundTime;
        
        [SerializeField, Tooltip(@"Inner transactions produced by application execution.")]
        Transaction[] @innerTxns;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetConfig @assetConfigTransaction;
        
        [SerializeField, Tooltip(@"[lv] Last valid round for this transaction.")]
        ulong @lastValid;
        
        [SerializeField, Tooltip(@"[rc] rewards applied to close-remainder-to account.")]
        Optional<ulong> @closeRewards;
        
        [SerializeField, Tooltip(@"[ld] Local state key/value changes for the application being executed by this transaction.")]
        AccountStateDelta[] @localStateDelta;
        
        [SerializeField, Tooltip(@"Transaction ID")]
        string @id;
        
        [SerializeField, Tooltip(@"[sgnr] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.")]
        Address @authAddr;
        
        [SerializeField, Tooltip(@"[gen] genesis block ID.")]
        string @genesisId;
        
        [SerializeField, Tooltip(@"[snd] Sender's address.")]
        string @sender;
        
        [SerializeField, Tooltip(@"")]
        TransactionApplication @applicationTransaction;
        
        [SerializeField, Tooltip(@"Specifies an asset index (ID) if an asset was created with this transaction.")]
        Optional<ulong> @createdAssetIndex;
        
        [SerializeField, Tooltip(@"[fv] First valid round for this transaction.")]
        ulong @firstValid;
        
        [SerializeField, Tooltip(@"[rekey] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.")]
        Address @rekeyTo;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetFreeze @assetFreezeTransaction;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("state-proof-transaction")]
        public TransactionStateProof StateProofTransaction
        {
            get => this.@stateProofTransaction;
            set => this.@stateProofTransaction = value;
        }

        /// <summary>
        /// [fee] Transaction fee.        
        /// </summary>
        [AlgoApiField("fee")]
        public ulong Fee
        {
            get => this.@fee;
            set => this.@fee = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-transfer-transaction")]
        public TransactionAssetTransfer AssetTransferTransaction
        {
            get => this.@assetTransferTransaction;
            set => this.@assetTransferTransaction = value;
        }

        /// <summary>
        /// [grp] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.        
        /// </summary>
        [AlgoApiField("group")]
        public byte[] Group
        {
            get => this.@group;
            set => this.@group = value;
        }

        /// <summary>
        /// Specifies an application index (ID) if an application was created with this transaction.        
        /// </summary>
        [AlgoApiField("created-application-index")]
        public Optional<ulong> CreatedApplicationIndex
        {
            get => this.@createdApplicationIndex;
            set => this.@createdApplicationIndex = value;
        }

        /// <summary>
        /// [lx] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.        
        /// </summary>
        [AlgoApiField("lease")]
        public byte[] Lease
        {
            get => this.@lease;
            set => this.@lease = value;
        }

        /// <summary>
        /// [gh] Hash of genesis block.        
        /// </summary>
        [AlgoApiField("genesis-hash")]
        public byte[] GenesisHash
        {
            get => this.@genesisHash;
            set => this.@genesisHash = value;
        }

        /// <summary>
        /// [lg] Logs for the application being executed by this transaction.        
        /// </summary>
        [AlgoApiField("logs")]
        public byte[][] Logs
        {
            get => this.@logs;
            set => this.@logs = value;
        }

        /// <summary>
        /// [rs] rewards applied to sender account.        
        /// </summary>
        [AlgoApiField("sender-rewards")]
        public Optional<ulong> SenderRewards
        {
            get => this.@senderRewards;
            set => this.@senderRewards = value;
        }

        /// <summary>
        /// [ca] closing amount for transaction.        
        /// </summary>
        [AlgoApiField("closing-amount")]
        public Optional<ulong> ClosingAmount
        {
            get => this.@closingAmount;
            set => this.@closingAmount = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("signature")]
        public TransactionSignature Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        /// <summary>
        /// [gd] Global state key/value changes for the application being executed by this transaction.        
        /// </summary>
        [AlgoApiField("global-state-delta")]
        public StateDelta GlobalStateDelta
        {
            get => this.@globalStateDelta;
            set => this.@globalStateDelta = value;
        }

        /// <summary>
        /// [type] Indicates what type of transaction this is. Different types have different fields.
        /// 
        /// Valid types, and where their fields are stored:
        /// * [pay] payment-transaction
        /// * [keyreg] keyreg-transaction
        /// * [acfg] asset-config-transaction
        /// * [axfer] asset-transfer-transaction
        /// * [afrz] asset-freeze-transaction
        /// * [appl] application-transaction
        /// * [stpf] state-proof-transaction        
        /// </summary>
        [AlgoApiField("tx-type")]
        public string TxType
        {
            get => this.@txType;
            set => this.@txType = value;
        }

        /// <summary>
        /// Offset into the round where this transaction was confirmed.        
        /// </summary>
        [AlgoApiField("intra-round-offset")]
        public Optional<ulong> IntraRoundOffset
        {
            get => this.@intraRoundOffset;
            set => this.@intraRoundOffset = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("payment-transaction")]
        public TransactionPayment PaymentTransaction
        {
            get => this.@paymentTransaction;
            set => this.@paymentTransaction = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("keyreg-transaction")]
        public TransactionKeyreg KeyregTransaction
        {
            get => this.@keyregTransaction;
            set => this.@keyregTransaction = value;
        }

        /// <summary>
        /// Round when the transaction was confirmed.        
        /// </summary>
        [AlgoApiField("confirmed-round")]
        public Optional<ulong> ConfirmedRound
        {
            get => this.@confirmedRound;
            set => this.@confirmedRound = value;
        }

        /// <summary>
        /// [note] Free form data.        
        /// </summary>
        [AlgoApiField("note")]
        public byte[] Note
        {
            get => this.@note;
            set => this.@note = value;
        }

        /// <summary>
        /// [rr] rewards applied to receiver account.        
        /// </summary>
        [AlgoApiField("receiver-rewards")]
        public Optional<ulong> ReceiverRewards
        {
            get => this.@receiverRewards;
            set => this.@receiverRewards = value;
        }

        /// <summary>
        /// Time when the block this transaction is in was confirmed.        
        /// </summary>
        [AlgoApiField("round-time")]
        public Optional<ulong> RoundTime
        {
            get => this.@roundTime;
            set => this.@roundTime = value;
        }

        /// <summary>
        /// Inner transactions produced by application execution.        
        /// </summary>
        [AlgoApiField("inner-txns")]
        public Transaction[] InnerTxns
        {
            get => this.@innerTxns;
            set => this.@innerTxns = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-config-transaction")]
        public TransactionAssetConfig AssetConfigTransaction
        {
            get => this.@assetConfigTransaction;
            set => this.@assetConfigTransaction = value;
        }

        /// <summary>
        /// [lv] Last valid round for this transaction.        
        /// </summary>
        [AlgoApiField("last-valid")]
        public ulong LastValid
        {
            get => this.@lastValid;
            set => this.@lastValid = value;
        }

        /// <summary>
        /// [rc] rewards applied to close-remainder-to account.        
        /// </summary>
        [AlgoApiField("close-rewards")]
        public Optional<ulong> CloseRewards
        {
            get => this.@closeRewards;
            set => this.@closeRewards = value;
        }

        /// <summary>
        /// [ld] Local state key/value changes for the application being executed by this transaction.        
        /// </summary>
        [AlgoApiField("local-state-delta")]
        public AccountStateDelta[] LocalStateDelta
        {
            get => this.@localStateDelta;
            set => this.@localStateDelta = value;
        }

        /// <summary>
        /// Transaction ID        
        /// </summary>
        [AlgoApiField("id")]
        public string Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        /// [sgnr] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.        
        /// </summary>
        [AlgoApiField("auth-addr")]
        public Address AuthAddr
        {
            get => this.@authAddr;
            set => this.@authAddr = value;
        }

        /// <summary>
        /// [gen] genesis block ID.        
        /// </summary>
        [AlgoApiField("genesis-id")]
        public string GenesisId
        {
            get => this.@genesisId;
            set => this.@genesisId = value;
        }

        /// <summary>
        /// [snd] Sender's address.        
        /// </summary>
        [AlgoApiField("sender")]
        public string Sender
        {
            get => this.@sender;
            set => this.@sender = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("application-transaction")]
        public TransactionApplication ApplicationTransaction
        {
            get => this.@applicationTransaction;
            set => this.@applicationTransaction = value;
        }

        /// <summary>
        /// Specifies an asset index (ID) if an asset was created with this transaction.        
        /// </summary>
        [AlgoApiField("created-asset-index")]
        public Optional<ulong> CreatedAssetIndex
        {
            get => this.@createdAssetIndex;
            set => this.@createdAssetIndex = value;
        }

        /// <summary>
        /// [fv] First valid round for this transaction.        
        /// </summary>
        [AlgoApiField("first-valid")]
        public ulong FirstValid
        {
            get => this.@firstValid;
            set => this.@firstValid = value;
        }

        /// <summary>
        /// [rekey] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.        
        /// </summary>
        [AlgoApiField("rekey-to")]
        public Address RekeyTo
        {
            get => this.@rekeyTo;
            set => this.@rekeyTo = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-freeze-transaction")]
        public TransactionAssetFreeze AssetFreezeTransaction
        {
            get => this.@assetFreezeTransaction;
            set => this.@assetFreezeTransaction = value;
        }

        public bool Equals(Transaction other)
        {
            return 
                StateProofTransaction.Equals(other.StateProofTransaction) &&
                Fee.Equals(other.Fee) &&
                AssetTransferTransaction.Equals(other.AssetTransferTransaction) &&
                ArrayComparer.Equals(Group, other.Group) &&
                CreatedApplicationIndex.Equals(other.CreatedApplicationIndex) &&
                ArrayComparer.Equals(Lease, other.Lease) &&
                ArrayComparer.Equals(GenesisHash, other.GenesisHash) &&
                ArrayComparer.Equals(Logs, other.Logs) &&
                SenderRewards.Equals(other.SenderRewards) &&
                ClosingAmount.Equals(other.ClosingAmount) &&
                Signature.Equals(other.Signature) &&
                GlobalStateDelta.Equals(other.GlobalStateDelta) &&
                StringComparer.Equals(TxType, other.TxType) &&
                IntraRoundOffset.Equals(other.IntraRoundOffset) &&
                PaymentTransaction.Equals(other.PaymentTransaction) &&
                KeyregTransaction.Equals(other.KeyregTransaction) &&
                ConfirmedRound.Equals(other.ConfirmedRound) &&
                ArrayComparer.Equals(Note, other.Note) &&
                ReceiverRewards.Equals(other.ReceiverRewards) &&
                RoundTime.Equals(other.RoundTime) &&
                ArrayComparer.Equals(InnerTxns, other.InnerTxns) &&
                AssetConfigTransaction.Equals(other.AssetConfigTransaction) &&
                LastValid.Equals(other.LastValid) &&
                CloseRewards.Equals(other.CloseRewards) &&
                ArrayComparer.Equals(LocalStateDelta, other.LocalStateDelta) &&
                StringComparer.Equals(Id, other.Id) &&
                AuthAddr.Equals(other.AuthAddr) &&
                StringComparer.Equals(GenesisId, other.GenesisId) &&
                StringComparer.Equals(Sender, other.Sender) &&
                ApplicationTransaction.Equals(other.ApplicationTransaction) &&
                CreatedAssetIndex.Equals(other.CreatedAssetIndex) &&
                FirstValid.Equals(other.FirstValid) &&
                RekeyTo.Equals(other.RekeyTo) &&
                AssetFreezeTransaction.Equals(other.AssetFreezeTransaction)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionStateProof
        : IEquatable<TransactionStateProof>
    {
        [SerializeField, Tooltip(@"[sptype] Type of the state proof. Integer representing an entry defined in protocol/stateproof.go")]
        Optional<ulong> @stateProofType;
        
        [SerializeField, Tooltip(@"")]
        StateProofFields @stateProof;
        
        [SerializeField, Tooltip(@"[spmsg]")]
        IndexerStateProofMessage @message;
        
        /// <summary>
        /// [sptype] Type of the state proof. Integer representing an entry defined in protocol/stateproof.go        
        /// </summary>
        [AlgoApiField("state-proof-type")]
        public Optional<ulong> StateProofType
        {
            get => this.@stateProofType;
            set => this.@stateProofType = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("state-proof")]
        public StateProofFields StateProof
        {
            get => this.@stateProof;
            set => this.@stateProof = value;
        }

        /// <summary>
        /// [spmsg]        
        /// </summary>
        [AlgoApiField("message")]
        public IndexerStateProofMessage Message
        {
            get => this.@message;
            set => this.@message = value;
        }

        public bool Equals(TransactionStateProof other)
        {
            return 
                StateProofType.Equals(other.StateProofType) &&
                StateProof.Equals(other.StateProof) &&
                Message.Equals(other.Message)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofSigSlot
        : IEquatable<StateProofSigSlot>
    {
        [SerializeField, Tooltip(@"")]
        StateProofSignature @signature;
        
        [SerializeField, Tooltip(@"[l] The total weight of signatures in the lower-numbered slots.")]
        Optional<ulong> @lowerSigWeight;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("signature")]
        public StateProofSignature Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        /// <summary>
        /// [l] The total weight of signatures in the lower-numbered slots.        
        /// </summary>
        [AlgoApiField("lower-sig-weight")]
        public Optional<ulong> LowerSigWeight
        {
            get => this.@lowerSigWeight;
            set => this.@lowerSigWeight = value;
        }

        public bool Equals(StateProofSigSlot other)
        {
            return 
                Signature.Equals(other.Signature) &&
                LowerSigWeight.Equals(other.LowerSigWeight)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateProofVerifier
        : IEquatable<StateProofVerifier>
    {
        [SerializeField, Tooltip(@"[cmt] Represents the root of the vector commitment tree.")]
        byte[] @commitment;
        
        [SerializeField, Tooltip(@"[lf] Key lifetime.")]
        Optional<ulong> @keyLifetime;
        
        /// <summary>
        /// [cmt] Represents the root of the vector commitment tree.        
        /// </summary>
        [AlgoApiField("commitment")]
        public byte[] Commitment
        {
            get => this.@commitment;
            set => this.@commitment = value;
        }

        /// <summary>
        /// [lf] Key lifetime.        
        /// </summary>
        [AlgoApiField("key-lifetime")]
        public Optional<ulong> KeyLifetime
        {
            get => this.@keyLifetime;
            set => this.@keyLifetime = value;
        }

        public bool Equals(StateProofVerifier other)
        {
            return 
                ArrayComparer.Equals(Commitment, other.Commitment) &&
                KeyLifetime.Equals(other.KeyLifetime)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetParams
        : IEquatable<AssetParams>
    {
        [SerializeField, Tooltip(@"[df] Whether holdings of this asset are frozen by default.")]
        Optional<bool> @defaultFrozen;
        
        [SerializeField, Tooltip(@"The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.")]
        string @creator;
        
        [SerializeField, Tooltip(@"[dc] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).")]
        ulong @decimals;
        
        [SerializeField, Tooltip(@"[f] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.")]
        string @freeze;
        
        [SerializeField, Tooltip(@"[r] Address of account holding reserve (non-minted) units of this asset.")]
        string @reserve;
        
        [SerializeField, Tooltip(@"Base64 encoded name of a unit of this asset, as supplied by the creator.")]
        byte[] @unitNameB64;
        
        [SerializeField, Tooltip(@"[an] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.")]
        string @name;
        
        [SerializeField, Tooltip(@"Base64 encoded URL where more information about the asset can be retrieved.")]
        byte[] @urlB64;
        
        [SerializeField, Tooltip(@"[t] The total number of units of this asset.")]
        ulong @total;
        
        [SerializeField, Tooltip(@"[m] Address of account used to manage the keys of this asset and to destroy it.")]
        string @manager;
        
        [SerializeField, Tooltip(@"Base64 encoded name of this asset, as supplied by the creator.")]
        byte[] @nameB64;
        
        [SerializeField, Tooltip(@"[au] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.")]
        string @url;
        
        [SerializeField, Tooltip(@"[un] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.")]
        string @unitName;
        
        [SerializeField, Tooltip(@"[c] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.")]
        string @clawback;
        
        [SerializeField, Tooltip(@"[am] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.")]
        byte[] @metadataHash;
        
        /// <summary>
        /// [df] Whether holdings of this asset are frozen by default.        
        /// </summary>
        [AlgoApiField("default-frozen")]
        public Optional<bool> DefaultFrozen
        {
            get => this.@defaultFrozen;
            set => this.@defaultFrozen = value;
        }

        /// <summary>
        /// The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.        
        /// </summary>
        [AlgoApiField("creator")]
        public string Creator
        {
            get => this.@creator;
            set => this.@creator = value;
        }

        /// <summary>
        /// [dc] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).        
        /// </summary>
        [AlgoApiField("decimals")]
        public ulong Decimals
        {
            get => this.@decimals;
            set => this.@decimals = value;
        }

        /// <summary>
        /// [f] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.        
        /// </summary>
        [AlgoApiField("freeze")]
        public string Freeze
        {
            get => this.@freeze;
            set => this.@freeze = value;
        }

        /// <summary>
        /// [r] Address of account holding reserve (non-minted) units of this asset.        
        /// </summary>
        [AlgoApiField("reserve")]
        public string Reserve
        {
            get => this.@reserve;
            set => this.@reserve = value;
        }

        /// <summary>
        /// Base64 encoded name of a unit of this asset, as supplied by the creator.        
        /// </summary>
        [AlgoApiField("unit-name-b64")]
        public byte[] UnitNameB64
        {
            get => this.@unitNameB64;
            set => this.@unitNameB64 = value;
        }

        /// <summary>
        /// [an] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("name")]
        public string Name
        {
            get => this.@name;
            set => this.@name = value;
        }

        /// <summary>
        /// Base64 encoded URL where more information about the asset can be retrieved.        
        /// </summary>
        [AlgoApiField("url-b64")]
        public byte[] UrlB64
        {
            get => this.@urlB64;
            set => this.@urlB64 = value;
        }

        /// <summary>
        /// [t] The total number of units of this asset.        
        /// </summary>
        [AlgoApiField("total")]
        public ulong Total
        {
            get => this.@total;
            set => this.@total = value;
        }

        /// <summary>
        /// [m] Address of account used to manage the keys of this asset and to destroy it.        
        /// </summary>
        [AlgoApiField("manager")]
        public string Manager
        {
            get => this.@manager;
            set => this.@manager = value;
        }

        /// <summary>
        /// Base64 encoded name of this asset, as supplied by the creator.        
        /// </summary>
        [AlgoApiField("name-b64")]
        public byte[] NameB64
        {
            get => this.@nameB64;
            set => this.@nameB64 = value;
        }

        /// <summary>
        /// [au] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("url")]
        public string Url
        {
            get => this.@url;
            set => this.@url = value;
        }

        /// <summary>
        /// [un] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("unit-name")]
        public string UnitName
        {
            get => this.@unitName;
            set => this.@unitName = value;
        }

        /// <summary>
        /// [c] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.        
        /// </summary>
        [AlgoApiField("clawback")]
        public string Clawback
        {
            get => this.@clawback;
            set => this.@clawback = value;
        }

        /// <summary>
        /// [am] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.        
        /// </summary>
        [AlgoApiField("metadata-hash")]
        public byte[] MetadataHash
        {
            get => this.@metadataHash;
            set => this.@metadataHash = value;
        }

        public bool Equals(AssetParams other)
        {
            return 
                DefaultFrozen.Equals(other.DefaultFrozen) &&
                StringComparer.Equals(Creator, other.Creator) &&
                Decimals.Equals(other.Decimals) &&
                StringComparer.Equals(Freeze, other.Freeze) &&
                StringComparer.Equals(Reserve, other.Reserve) &&
                ArrayComparer.Equals(UnitNameB64, other.UnitNameB64) &&
                StringComparer.Equals(Name, other.Name) &&
                ArrayComparer.Equals(UrlB64, other.UrlB64) &&
                Total.Equals(other.Total) &&
                StringComparer.Equals(Manager, other.Manager) &&
                ArrayComparer.Equals(NameB64, other.NameB64) &&
                StringComparer.Equals(Url, other.Url) &&
                StringComparer.Equals(UnitName, other.UnitName) &&
                StringComparer.Equals(Clawback, other.Clawback) &&
                ArrayComparer.Equals(MetadataHash, other.MetadataHash)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct IndexerStateProofMessage
        : IEquatable<IndexerStateProofMessage>
    {
        [SerializeField, Tooltip(@"[b]")]
        byte[] @blockHeadersCommitment;
        
        [SerializeField, Tooltip(@"[v]")]
        byte[] @votersCommitment;
        
        [SerializeField, Tooltip(@"[P]")]
        Optional<ulong> @lnProvenWeight;
        
        [SerializeField, Tooltip(@"[f]")]
        Optional<ulong> @firstAttestedRound;
        
        [SerializeField, Tooltip(@"[l]")]
        Optional<ulong> @latestAttestedRound;
        
        /// <summary>
        /// [b]        
        /// </summary>
        [AlgoApiField("block-headers-commitment")]
        public byte[] BlockHeadersCommitment
        {
            get => this.@blockHeadersCommitment;
            set => this.@blockHeadersCommitment = value;
        }

        /// <summary>
        /// [v]        
        /// </summary>
        [AlgoApiField("voters-commitment")]
        public byte[] VotersCommitment
        {
            get => this.@votersCommitment;
            set => this.@votersCommitment = value;
        }

        /// <summary>
        /// [P]        
        /// </summary>
        [AlgoApiField("ln-proven-weight")]
        public Optional<ulong> LnProvenWeight
        {
            get => this.@lnProvenWeight;
            set => this.@lnProvenWeight = value;
        }

        /// <summary>
        /// [f]        
        /// </summary>
        [AlgoApiField("first-attested-round")]
        public Optional<ulong> FirstAttestedRound
        {
            get => this.@firstAttestedRound;
            set => this.@firstAttestedRound = value;
        }

        /// <summary>
        /// [l]        
        /// </summary>
        [AlgoApiField("latest-attested-round")]
        public Optional<ulong> LatestAttestedRound
        {
            get => this.@latestAttestedRound;
            set => this.@latestAttestedRound = value;
        }

        public bool Equals(IndexerStateProofMessage other)
        {
            return 
                ArrayComparer.Equals(BlockHeadersCommitment, other.BlockHeadersCommitment) &&
                ArrayComparer.Equals(VotersCommitment, other.VotersCommitment) &&
                LnProvenWeight.Equals(other.LnProvenWeight) &&
                FirstAttestedRound.Equals(other.FirstAttestedRound) &&
                LatestAttestedRound.Equals(other.LatestAttestedRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockUpgradeState
        : IEquatable<BlockUpgradeState>
    {
        [SerializeField, Tooltip(@"[proto] The current protocol version.")]
        string @currentProtocol;
        
        [SerializeField, Tooltip(@"[nextproto] The next proposed protocol version.")]
        string @nextProtocol;
        
        [SerializeField, Tooltip(@"[nextyes] Number of blocks which approved the protocol upgrade.")]
        Optional<ulong> @nextProtocolApprovals;
        
        [SerializeField, Tooltip(@"[nextswitch] Round on which the protocol upgrade will take effect.")]
        Optional<ulong> @nextProtocolSwitchOn;
        
        [SerializeField, Tooltip(@"[nextbefore] Deadline round for this protocol upgrade (No votes will be consider after this round).")]
        Optional<ulong> @nextProtocolVoteBefore;
        
        /// <summary>
        /// [proto] The current protocol version.        
        /// </summary>
        [AlgoApiField("current-protocol")]
        public string CurrentProtocol
        {
            get => this.@currentProtocol;
            set => this.@currentProtocol = value;
        }

        /// <summary>
        /// [nextproto] The next proposed protocol version.        
        /// </summary>
        [AlgoApiField("next-protocol")]
        public string NextProtocol
        {
            get => this.@nextProtocol;
            set => this.@nextProtocol = value;
        }

        /// <summary>
        /// [nextyes] Number of blocks which approved the protocol upgrade.        
        /// </summary>
        [AlgoApiField("next-protocol-approvals")]
        public Optional<ulong> NextProtocolApprovals
        {
            get => this.@nextProtocolApprovals;
            set => this.@nextProtocolApprovals = value;
        }

        /// <summary>
        /// [nextswitch] Round on which the protocol upgrade will take effect.        
        /// </summary>
        [AlgoApiField("next-protocol-switch-on")]
        public Optional<ulong> NextProtocolSwitchOn
        {
            get => this.@nextProtocolSwitchOn;
            set => this.@nextProtocolSwitchOn = value;
        }

        /// <summary>
        /// [nextbefore] Deadline round for this protocol upgrade (No votes will be consider after this round).        
        /// </summary>
        [AlgoApiField("next-protocol-vote-before")]
        public Optional<ulong> NextProtocolVoteBefore
        {
            get => this.@nextProtocolVoteBefore;
            set => this.@nextProtocolVoteBefore = value;
        }

        public bool Equals(BlockUpgradeState other)
        {
            return 
                StringComparer.Equals(CurrentProtocol, other.CurrentProtocol) &&
                StringComparer.Equals(NextProtocol, other.NextProtocol) &&
                NextProtocolApprovals.Equals(other.NextProtocolApprovals) &&
                NextProtocolSwitchOn.Equals(other.NextProtocolSwitchOn) &&
                NextProtocolVoteBefore.Equals(other.NextProtocolVoteBefore)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct MerkleArrayProof
        : IEquatable<MerkleArrayProof>
    {
        [SerializeField, Tooltip(@"[pth]")]
        byte[][] @path;
        
        [SerializeField, Tooltip(@"")]
        HashFactory @hashFactory;
        
        [SerializeField, Tooltip(@"[td]")]
        Optional<ulong> @treeDepth;
        
        /// <summary>
        /// [pth]        
        /// </summary>
        [AlgoApiField("path")]
        public byte[][] Path
        {
            get => this.@path;
            set => this.@path = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("hash-factory")]
        public HashFactory HashFactory
        {
            get => this.@hashFactory;
            set => this.@hashFactory = value;
        }

        /// <summary>
        /// [td]        
        /// </summary>
        [AlgoApiField("tree-depth")]
        public Optional<ulong> TreeDepth
        {
            get => this.@treeDepth;
            set => this.@treeDepth = value;
        }

        public bool Equals(MerkleArrayProof other)
        {
            return 
                ArrayComparer.Equals(Path, other.Path) &&
                HashFactory.Equals(other.HashFactory) &&
                TreeDepth.Equals(other.TreeDepth)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetHoldingsResponse
        : IEquatable<AssetHoldingsResponse>
    {
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        [SerializeField, Tooltip(@"")]
        AssetHolding[] @assets;
        
        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("assets")]
        public AssetHolding[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        public bool Equals(AssetHoldingsResponse other)
        {
            return 
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken) &&
                ArrayComparer.Equals(Assets, other.Assets)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationResponse
        : IEquatable<ApplicationResponse>
    {
        [SerializeField, Tooltip(@"")]
        Application @application;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("application")]
        public Application Application
        {
            get => this.@application;
            set => this.@application = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(ApplicationResponse other)
        {
            return 
                Application.Equals(other.Application) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionsResponse
        : IEquatable<TransactionsResponse>
    {
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        [SerializeField, Tooltip(@"")]
        Transaction[] @transactions;
        
        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("transactions")]
        public Transaction[] Transactions
        {
            get => this.@transactions;
            set => this.@transactions = value;
        }

        public bool Equals(TransactionsResponse other)
        {
            return 
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken) &&
                ArrayComparer.Equals(Transactions, other.Transactions)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountsResponse
        : IEquatable<AccountsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Account[] @accounts;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("accounts")]
        public Account[] Accounts
        {
            get => this.@accounts;
            set => this.@accounts = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AccountsResponse other)
        {
            return 
                ArrayComparer.Equals(Accounts, other.Accounts) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetResponse
        : IEquatable<AssetResponse>
    {
        [SerializeField, Tooltip(@"")]
        Asset @asset;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset")]
        public Asset Asset
        {
            get => this.@asset;
            set => this.@asset = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(AssetResponse other)
        {
            return 
                Asset.Equals(other.Asset) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BoxesResponse
        : IEquatable<BoxesResponse>
    {
        [SerializeField, Tooltip(@"[appidx] application index.")]
        ulong @applicationId;
        
        [SerializeField, Tooltip(@"")]
        BoxDescriptor[] @boxes;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        /// [appidx] application index.        
        /// </summary>
        [AlgoApiField("application-id")]
        public ulong ApplicationId
        {
            get => this.@applicationId;
            set => this.@applicationId = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("boxes")]
        public BoxDescriptor[] Boxes
        {
            get => this.@boxes;
            set => this.@boxes = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(BoxesResponse other)
        {
            return 
                ApplicationId.Equals(other.ApplicationId) &&
                ArrayComparer.Equals(Boxes, other.Boxes) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetBalancesResponse
        : IEquatable<AssetBalancesResponse>
    {
        [SerializeField, Tooltip(@"")]
        MiniAssetHolding[] @balances;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("balances")]
        public MiniAssetHolding[] Balances
        {
            get => this.@balances;
            set => this.@balances = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AssetBalancesResponse other)
        {
            return 
                ArrayComparer.Equals(Balances, other.Balances) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountResponse
        : IEquatable<AccountResponse>
    {
        [SerializeField, Tooltip(@"")]
        Account @account;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("account")]
        public Account Account
        {
            get => this.@account;
            set => this.@account = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(AccountResponse other)
        {
            return 
                Account.Equals(other.Account) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationsResponse
        : IEquatable<ApplicationsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Application[] @applications;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("applications")]
        public Application[] Applications
        {
            get => this.@applications;
            set => this.@applications = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(ApplicationsResponse other)
        {
            return 
                ArrayComparer.Equals(Applications, other.Applications) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionResponse
        : IEquatable<TransactionResponse>
    {
        [SerializeField, Tooltip(@"")]
        Transaction @transaction;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("transaction")]
        public Transaction Transaction
        {
            get => this.@transaction;
            set => this.@transaction = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(TransactionResponse other)
        {
            return 
                Transaction.Equals(other.Transaction) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLogsResponse
        : IEquatable<ApplicationLogsResponse>
    {
        [SerializeField, Tooltip(@"[appidx] application index.")]
        ulong @applicationId;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        [SerializeField, Tooltip(@"")]
        ApplicationLogData[] @logData;
        
        /// <summary>
        /// [appidx] application index.        
        /// </summary>
        [AlgoApiField("application-id")]
        public ulong ApplicationId
        {
            get => this.@applicationId;
            set => this.@applicationId = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("log-data")]
        public ApplicationLogData[] LogData
        {
            get => this.@logData;
            set => this.@logData = value;
        }

        public bool Equals(ApplicationLogsResponse other)
        {
            return 
                ApplicationId.Equals(other.ApplicationId) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken) &&
                ArrayComparer.Equals(LogData, other.LogData)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetsResponse
        : IEquatable<AssetsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Asset[] @assets;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("assets")]
        public Asset[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AssetsResponse other)
        {
            return 
                ArrayComparer.Equals(Assets, other.Assets) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLocalStatesResponse
        : IEquatable<ApplicationLocalStatesResponse>
    {
        [SerializeField, Tooltip(@"")]
        ApplicationLocalState[] @appsLocalStates;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("apps-local-states")]
        public ApplicationLocalState[] AppsLocalStates
        {
            get => this.@appsLocalStates;
            set => this.@appsLocalStates = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(ApplicationLocalStatesResponse other)
        {
            return 
                ArrayComparer.Equals(AppsLocalStates, other.AppsLocalStates) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    /// <summary>
    /// Application state delta.    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<StateDelta, EvalDeltaKeyValue[]>))]
    public partial struct StateDelta
        : IEquatable<StateDelta>
        , IWrappedValue<EvalDeltaKeyValue[]>
    {
        [SerializeField]
        EvalDeltaKeyValue[] @value;

        public StateDelta(EvalDeltaKeyValue[] value)
        {
            this.@value = value;
        }

        public EvalDeltaKeyValue[] WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(StateDelta other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator EvalDeltaKeyValue[](StateDelta wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator StateDelta(EvalDeltaKeyValue[] value)
        {
            return new StateDelta(value);
        }
    }
    
    /// <summary>
    /// Represents a key-value store for use in an application.    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<TealKeyValueStore, TealKeyValue[]>))]
    public partial struct TealKeyValueStore
        : IEquatable<TealKeyValueStore>
        , IWrappedValue<TealKeyValue[]>
    {
        [SerializeField]
        TealKeyValue[] @value;

        public TealKeyValueStore(TealKeyValue[] value)
        {
            this.@value = value;
        }

        public TealKeyValue[] WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(TealKeyValueStore other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator TealKeyValue[](TealKeyValueStore wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator TealKeyValueStore(TealKeyValue[] value)
        {
            return new TealKeyValueStore(value);
        }
    }
    
    /// <summary>
    /// (empty)    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<BlockResponse, Block>))]
    public partial struct BlockResponse
        : IEquatable<BlockResponse>
        , IWrappedValue<Block>
    {
        [SerializeField]
        Block @value;

        public BlockResponse(Block value)
        {
            this.@value = value;
        }

        public Block WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(BlockResponse other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator Block(BlockResponse wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator BlockResponse(Block value)
        {
            return new BlockResponse(value);
        }
    }
    
    /// <summary>
    /// (empty)    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<HealthCheckResponse, HealthCheck>))]
    public partial struct HealthCheckResponse
        : IEquatable<HealthCheckResponse>
        , IWrappedValue<HealthCheck>
    {
        [SerializeField]
        HealthCheck @value;

        public HealthCheckResponse(HealthCheck value)
        {
            this.@value = value;
        }

        public HealthCheck WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(HealthCheckResponse other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator HealthCheck(HealthCheckResponse wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator HealthCheckResponse(HealthCheck value)
        {
            return new HealthCheckResponse(value);
        }
    }
    
    /// <summary>
    /// Box information    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<BoxResponse, Box>))]
    public partial struct BoxResponse
        : IEquatable<BoxResponse>
        , IWrappedValue<Box>
    {
        [SerializeField]
        Box @value;

        public BoxResponse(Box value)
        {
            this.@value = value;
        }

        public Box WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(BoxResponse other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator Box(BoxResponse wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator BoxResponse(Box value)
        {
            return new BoxResponse(value);
        }
    }
    
}
